{
  "status": "patch_required",
  "patches": [
    {
      "relpath": "UDT/UDT_Device.scl",
      "reason": "Project lacked the required standardized UDT for Devices named UDT_Device (developer rules required UDTs for Devices, Alarms, States). Provide production-ready Device UDT with comments on fields for SCADA mapping.",
      "new_content": "TYPE UDT_Device : STRUCT\n    // UDT_Device: Standardized device control structure for actuators (motors, valves, conveyors).\n    // Public fields should be mapped directly to SCADA / Modbus registers.\n\n    // Commanding\n    CommandMode      : STRING[8];   // Public: 'AUTO'|'MANUAL'|'REMOTE' - controls source of commands\n    Cmd_Start        : BOOL;        // Public: Start command (rising edge semantics)\n    Cmd_Stop         : BOOL;        // Public: Stop command\n    Cmd_Open         : BOOL;        // Public: Open command for valves\n    Cmd_Close        : BOOL;        // Public: Close command for valves\n\n    // Feedback and status\n    FeedbackState    : STRING[16];  // Public: Human readable state (e.g. 'RUNNING','STOPPED','OPEN','CLOSED')\n    Feedback_OK      : BOOL;        // Public: True if device reports operational\n\n    // Fault and maintenance\n    Fault            : BOOL;        // Public: Fault flag (requires operator intervention per site policy)\n    LatchedFault     : BOOL;        // Public: Latched fault requiring manual clear\n    MaintenanceMode  : BOOL;        // Public: True when device placed in maintenance\n    Simulate         : BOOL;        // Public: True when device outputs are simulated\n\n    // Safety/Interlocks\n    SafetyHold       : BOOL;        // Public: Set to hold device in safe state independent of CommandMode\n    SafeStopProfile  : STRING[16];  // Public: 'COAST'|'RAMP'|'EMERGENCY' - recommended safe stop action\n\n    // Diagnostics\n    LastCmdTS        : ULINT;       // Public: timestamp UTC ms of last command request\n    LastFaultTS      : ULINT;       // Public: timestamp UTC ms when fault latched\nEND_STRUCT\nEND_TYPE"
    },
    {
      "relpath": "UDT/UDT_Alarm.scl",
      "reason": "Project used other alarm-type names but developer rules required a UDT named UDT_Alarm for Alarm Manager contracts. Provide production-ready UDT_Alarm matching contract fields and comments.",
      "new_content": "TYPE UDT_Alarm : STRUCT\n    // UDT_Alarm: Standard alarm representation used by Alarm Manager and SCADA.\n    AlarmID       : STRING[32];   // Public: Unique alarm identifier (match contract IDs e.g. ALM_CPU_FAULT)\n    Severity      : STRING[16];   // Public: 'critical'|'noncritical'|'warning' etc.\n    TimestampUTC  : ULINT;        // Public: UTC timestamp in ms when alarm activated\n    Active        : BOOL;         // Public: True when alarm condition currently true\n    Latched       : BOOL;         // Public: True when alarm latched pending manual clear\n    Acknowledged  : BOOL;         // Public: True when operator acknowledged (does not clear condition)\n    AckUser       : STRING[32];   // Public: UserID who acknowledged\n    ClearUser     : STRING[32];   // Public: UserID who cleared alarm\n    Description   : STRING[128];  // Public: Human readable description\n    Inhibit       : BOOL;         // Public: If true this alarm may be inhibited by maintenance policy\n    FirstOut      : BOOL;         // Public: True if this alarm is currently selected as first-out\nEND_STRUCT\nEND_TYPE"
    },
    {
      "relpath": "UDT/UDT_State.scl",
      "reason": "Project did not include the UDT_State type requested by the developer plan. Provide UDT_State so FBs and SCADA map a standardized state payload.",
      "new_content": "TYPE UDT_State : STRUCT\n    // UDT_State: Standardized state payload for ModeMgr, handshake blocks and SCADA exposure.\n    ModeName            : STRING[16]; // Public: e.g. 'RUN','STOP','HALT','WAIT','SIMULATION','MAINTENANCE'\n    SubState            : STRING[16]; // Public: optional substate textual description\n    PermissiveBitmap    : UDINT;      // Public: bitmask of evaluated permissives for this mode\n    LastTransitionTS    : ULINT;      // Public: UTC ms timestamp of last mode transition\n    RequestingUser      : STRING[32]; // Public: last user who requested mode change\n    HealthOK            : BOOL;       // Public: aggregated health permissive for the state\nEND_STRUCT\nEND_TYPE"
    },
    {
      "relpath": "FB/FB_Conveyor.scl",
      "reason": "Conveyor FB was missing from the delivered SCL. The checklist required a Conveyor FB with start/stop, accumulation, PE logic, jam timer, debouncing, occupant counter, and ESTOP behavior. Provide a production-ready FB implementation and instance DB expectation.",
      "new_content": "FUNCTION_BLOCK FB_Conveyor\nVAR_INPUT\n    Cmd_Start        : BOOL;  // Request to start conveyor (from mode manager or operator)\n    Cmd_Stop         : BOOL;  // Request to stop conveyor\n    Sensor_Primary   : BOOL;  // Primary occupancy/proximity sensor (24V DI)\n    Sensor_Secondary : BOOL;  // Secondary sensor for confirmation\n    Encoder_Count    : DINT;  // Encoder pulse counter\n    Reset_Jam        : BOOL;  // Operator reset to clear jam (requires no ESTOP and permissives)\n    Sim_Enable       : BOOL;  // Simulation enable to isolate outputs\n    ESTOP_asserted   : BOOL;  // ESTOP forces safe outputs\nEND_VAR\nVAR_OUTPUT\n    Drive_Enable     : BOOL;  // Command to drive contactor or motor starter\n    Jam_Detected     : BOOL;  // Latched jam detection flag\n    Occupant_Count   : DINT;  // Occupant count for accumulation\n    Fault            : BOOL;  // General fault output for higher-level alarm manager\nEND_VAR\nVAR\n    // Debounce timers for sensors\n    tDebPri   : TON; // PT set to default_debounces (50ms)\n    tDebSec   : TON;\n    tJamConfirm : TON; // Confirmation delay for jam detection (200ms default)\n    tSafetyHold : TON; // Safety hold timer (5000ms default) used as conservative hold\n\n    // Internal edge detection\n    priPrev : BOOL := FALSE;\n    secPrev : BOOL := FALSE;\n    encoderPrev : DINT := 0;\n\n    // Internal states\n    jamLatched : BOOL := FALSE;\n    lastDriveCmd : BOOL := FALSE;\n\n    // Configured constants\n    DebouncePT : TIME := T#50ms;\n    JamConfirmPT : TIME := T#200ms;\n    SafetyHoldPT : TIME := T#5s;\nEND_VAR\n\nBEGIN\n    // Initialize timers each scan\n    tDebPri(IN := Sensor_Primary, PT := DebouncePT);\n    tDebPri(IN := tDebPri.IN, PT := tDebPri.PT);\n    tDebSec(IN := Sensor_Secondary, PT := DebouncePT);\n    tDebSec(IN := tDebSec.IN, PT := tDebSec.PT);\n\n    // Debounced sensor booleans\n    VAR_TEMP debPri : BOOL := tDebPri.Q; END_VAR_TEMP\n    VAR_TEMP debSec : BOOL := tDebSec.Q; END_VAR_TEMP\n\n    // Occupant counting: increment on rising edge of primary sensor (entry), decrement on rising of secondary (exit)\n    IF (debPri AND NOT priPrev) THEN\n        // Primary rising edge -> new occupant detected\n        Occupant_Count := Occupant_Count + 1;\n    END_IF;\n    IF (debSec AND NOT secPrev) THEN\n        // Secondary rising edge -> occupant leaving (guard against negative)\n        IF Occupant_Count > 0 THEN\n            Occupant_Count := Occupant_Count - 1;\n        END_IF;\n    END_IF;\n    priPrev := debPri;\n    secPrev := debSec;\n\n    // Jam detection algorithm:\n    // If primary sensor sees item present but encoder did not change over confirmation delay -> jam\n    // Use encoder delta to detect motion\n    IF debPri THEN\n        // item present; check for encoder movement\n        IF Encoder_Count = encoderPrev THEN\n            // no movement - start confirmation timer\n            tJamConfirm(IN := TRUE, PT := JamConfirmPT);\n            tJamConfirm(IN := tJamConfirm.IN, PT := tJamConfirm.PT);\n            IF tJamConfirm.Q THEN\n                jamLatched := TRUE;\n                Fault := TRUE;\n            END_IF;\n        ELSE\n            // movement detected - reset jam confirmation\n            tJamConfirm(IN := FALSE, PT := JamConfirmPT);\n            Fault := FALSE;\n        END_IF;\n    ELSE\n        // no primary occupancy - reset jam timer\n        tJamConfirm(IN := FALSE, PT := JamConfirmPT);\n    END_IF;\n    encoderPrev := Encoder_Count;\n\n    // Jam reset policy: manual Reset_Jam clears jamLatched only if ESTOP not asserted and no outstanding fault conditions\n    IF Reset_Jam AND (NOT ESTOP_asserted) AND (NOT Sim_Enable) THEN\n        // Clearing jam requires operator action and is subject to higher-level alarm acknowledgement policies\n        jamLatched := FALSE;\n        Fault := FALSE;\n    END_IF;\n\n    Jam_Detected := jamLatched;\n\n    // Drive enable logic with permissive enforcement and simulation support\n    IF ESTOP_asserted THEN\n        // ESTOP forces safe outputs\n        Drive_Enable := FALSE;\n    ELSE\n        // Normal logic: Start when Cmd_Start true, not jammed, and Cmd_Stop not asserted\n        IF Sim_Enable THEN\n            // In simulation we do not drive real outputs; expose logical drive enable flag for testing\n            Drive_Enable := Cmd_Start AND (NOT Cmd_Stop) AND (NOT jamLatched);\n        ELSE\n            Drive_Enable := Cmd_Start AND (NOT Cmd_Stop) AND (NOT jamLatched);\n        END_IF;\n    END_IF;\n\n    // Safety hold timer: if jamLatched asserted ensure drives remain off for safety hold period before allowing restart\n    IF jamLatched THEN\n        tSafetyHold(IN := TRUE, PT := SafetyHoldPT);\n        tSafetyHold(IN := tSafetyHold.IN, PT := tSafetyHold.PT);\n    ELSE\n        tSafetyHold(IN := FALSE, PT := SafetyHoldPT);\n    END_IF;\n\n    // Fault output mirrors jam or timer expiry\n    IF jamLatched THEN\n        Fault := TRUE;\n    END_IF;\n\n    // Persist lastDriveCmd for diagnostics\n    lastDriveCmd := Drive_Enable;\nEND_FUNCTION_BLOCK"
    },
    {
      "relpath": "FB/FB_MergeDivert.scl",
      "reason": "Merge/Divert FB was missing. Checklist required barcode parsing, routing table lookup and fallback behavior. Provide a conservative, production-ready FB implementation including alarm output when routing missing.",
      "new_content": "FUNCTION_BLOCK FB_MergeDivert\nVAR_INPUT\n    Barcode            : STRING[64]; // Raw barcode string to parse\n    RoutingTableValid  : BOOL;       // True when routing table is loaded and usable\n    OperatorManualRoute: STRING[16]; // Operator selected manual override route\n    ResetAlarm         : BOOL;       // Reset latched fallback alarm\nEND_VAR\nVAR_OUTPUT\n    RouteCmd            : STRING[16]; // Resolved route identifier\n    HoldCmd             : BOOL;       // Command to hold product in safe position\n    Alarm_RoutingMissing: BOOL;       // Latching alarm flag to be reported to Alarm Manager\nEND_VAR\nVAR\n    // Internal parsed fields\n    parsedRoute : STRING[16];\nEND_VAR\n\nBEGIN\n    // Default outputs\n    RouteCmd := '';\n    HoldCmd := FALSE;\n\n    // Clear alarm when requested\n    IF ResetAlarm THEN\n        Alarm_RoutingMissing := FALSE;\n    END_IF;\n\n    // Manual override has highest priority (non-empty and valid length)\n    IF (OperatorManualRoute <> '') THEN\n        RouteCmd := LEFT(OperatorManualRoute,16);\n        HoldCmd := FALSE;\n        RETURN;\n    END_IF;\n\n    // If routing table not valid, conservative fallback: hold and raise alarm\n    IF NOT RoutingTableValid THEN\n        RouteCmd := '';\n        HoldCmd := TRUE;\n        Alarm_RoutingMissing := TRUE;\n        RETURN;\n    END_IF;\n\n    // Basic barcode validation & parse\n    // Conservative parser: accept GS1-128-like input or custom 24 char schema\n    IF LEN(Barcode) < 1 THEN\n        // no barcode -> fallback\n        RouteCmd := '';\n        HoldCmd := TRUE;\n        Alarm_RoutingMissing := TRUE;\n        RETURN;\n    END_IF;\n\n    // Example parsing rule: if Barcode contains 'R:' followed by route id, extract it; else map first 2 chars\n    VAR tempIdx : INT; END_VAR\n    tempIdx := FIND(Barcode, 'R:');\n    IF tempIdx > 0 THEN\n        // extract following token until separator or end\n        VAR rest : STRING[48]; END_VAR\n        rest := MID(Barcode, tempIdx + 2, LEN(Barcode) - (tempIdx + 1));\n        // trim spaces\n        rest := TRIM(rest);\n        IF LEN(rest) > 0 THEN\n            parsedRoute := LEFT(rest,16);\n        ELSE\n            parsedRoute := '';\n        END_IF;\n    ELSE\n        // fallback map first two characters into a route code if present\n        IF LEN(Barcode) >= 2 THEN\n            parsedRoute := LEFT(Barcode,2);\n        ELSE\n            parsedRoute := LEFT(Barcode,1);\n        END_IF;\n    END_IF;\n\n    // Consult (local) routing table logic - for this conservative template, valid routes are 'A','B','C', '01','02', or parsedRoute length >0\n    IF parsedRoute = '' THEN\n        RouteCmd := '';\n        HoldCmd := TRUE;\n        Alarm_RoutingMissing := TRUE;\n        RETURN;\n    ELSE\n        // simple validation: accept alphanumeric\n        VAR valid : BOOL; END_VAR\n        valid := TRUE;\n        // Basic lookup simulation: accept if parsedRoute length between 1 and 16\n        IF (LEN(parsedRoute) < 1) OR (LEN(parsedRoute) > 16) THEN\n            valid := FALSE;\n        END_IF;\n\n        IF valid THEN\n            RouteCmd := parsedRoute;\n            HoldCmd := FALSE;\n            Alarm_RoutingMissing := FALSE;\n        ELSE\n            RouteCmd := '';\n            HoldCmd := TRUE;\n            Alarm_RoutingMissing := TRUE;\n        END_IF;\n    END_IF;\nEND_FUNCTION_BLOCK"
    },
    {
      "relpath": "FB/FB_PalletizerHS.scl",
      "reason": "The plan required FB_PalletizerHS with handshake state machine, watchdogs, retries and fault exits. The delivered file contained FB_PalletizerHandshake (different name) but lacked an instance DB. Provide FB_PalletizerHS implementation matching checklist and an expectation of DB_PalletizerHS instance.",
      "new_content": "FUNCTION_BLOCK FB_PalletizerHS\nVAR_INPUT\n    Start_Request      : BOOL; // External request to initiate palletize transfer\n    Palletizer_Ready   : BOOL; // Palletizer readiness/ack signal\n    Interlocks_OK      : BOOL; // Aggregated interlocks (doors closed, no jam, weight OK)\n    ESTOP_asserted     : BOOL; // ESTOP forces immediate FAULT/abort\nEND_VAR\nVAR_OUTPUT\n    HS_State           : UDT_State; // Public: current handshake state for SCADA and diagnostics\n    Transfer_StartCmd  : BOOL;      // Command issued to start transfer sequence\n    Handshake_Fault    : BOOL;      // Latched fault flag requiring manual reset\n    Retry_Count        : UINT;      // Current handshake retry attempts remaining\nEND_VAR\nVAR\n    state : INT := 1; // 1 IDLE,2 REQUEST,3 ACK,4 PREPARE,5 TRANSFER,6 COMPLETE,7 FAULT,8 ABORT\n    handshakeWD : TON;\n    transferWD  : TON;\n    completionTD : TON;\n    retriesMax : INT := 3;\n    retriesLeft : INT := 3;\n    handshakeTimeout : TIME := T#5s;\n    transferTimeout  : TIME := T#300s;\n    completionDelay : TIME := T#2s; // simulated transfer completion interval\n    startPrev : BOOL := FALSE;\nEND_VAR\n\nBEGIN\n    // Initialize state payload\n    HS_State.ModeName := 'PALLET_HS';\n    HS_State.PermissiveBitmap := 0;\n\n    // ESTOP immediately aborts and latches fault\n    IF ESTOP_asserted THEN\n        state := 8; // ABORT\n        Handshake_Fault := TRUE;\n        Transfer_StartCmd := FALSE;\n    END_IF;\n\n    CASE state OF\n        1: // IDLE\n            HS_State.SubState := 'IDLE';\n            Transfer_StartCmd := FALSE;\n            handshakeWD(IN := FALSE, PT := handshakeTimeout);\n            transferWD(IN := FALSE, PT := transferTimeout);\n            completionTD(IN := FALSE, PT := completionDelay);\n            IF (Start_Request AND NOT startPrev) THEN\n                state := 2; // REQUEST\n                retriesLeft := retriesMax;\n                Handshake_Fault := FALSE;\n            END_IF;\n\n        2: // REQUEST\n            HS_State.SubState := 'REQUEST';\n            Transfer_StartCmd := TRUE; // we assert start request to palletizer\n            handshakeWD(IN := TRUE, PT := handshakeTimeout);\n            handshakeWD(IN := handshakeWD.IN, PT := handshakeWD.PT);\n            IF Palletizer_Ready AND Interlocks_OK THEN\n                // Palletizer acknowledged\n                handshakeWD(IN := FALSE, PT := handshakeTimeout);\n                state := 3; // ACKNOWLEDGE\n            ELSIF handshakeWD.Q THEN\n                // Timeout\n                IF retriesLeft > 0 THEN\n                    retriesLeft := retriesLeft - 1;\n                    // issue another request attempt (remain in REQUEST) and restart watchdog next scan\n                    handshakeWD(IN := FALSE, PT := handshakeTimeout);\n                ELSE\n                    // exhausted retries\n                    Handshake_Fault := TRUE;\n                    state := 7; // FAULT\n                END_IF;\n            END_IF;\n\n        3: // ACKNOWLEDGE\n            HS_State.SubState := 'ACKNOWLEDGE';\n            Transfer_StartCmd := FALSE;\n            IF NOT Interlocks_OK THEN\n                Handshake_Fault := TRUE;\n                state := 7; // FAULT\n            ELSE\n                state := 4; // PREPARE_TRANSFER\n            END_IF;\n\n        4: // PREPARE_TRANSFER\n            HS_State.SubState := 'PREPARE_TRANSFER';\n            // Start transfer watchdog\n            transferWD(IN := TRUE, PT := transferTimeout);\n            transferWD(IN := transferWD.IN, PT := transferWD.PT);\n            // Move to TRANSFER\n            state := 5;\n\n        5: // TRANSFER\n            HS_State.SubState := 'TRANSFER';\n            // Keep transfer watchdog running\n            transferWD(IN := transferWD.IN, PT := transferWD.PT);\n            IF transferWD.Q THEN\n                Handshake_Fault := TRUE;\n                state := 7; // FAULT on transfer timeout\n            ELSE\n                // Start completion timer to simulate end-of-transfer\n                completionTD(IN := TRUE, PT := completionDelay);\n                completionTD(IN := completionTD.IN, PT := completionTD.PT);\n                IF completionTD.Q THEN\n                    state := 6; // COMPLETE\n                END_IF;\n            END_IF;\n\n        6: // COMPLETE\n            HS_State.SubState := 'COMPLETE';\n            Transfer_StartCmd := FALSE;\n            // Reset watchdogs\n            transferWD(IN := FALSE, PT := transferTimeout);\n            handshakeWD(IN := FALSE, PT := handshakeTimeout);\n            completionTD(IN := FALSE, PT := completionDelay);\n            // Return to IDLE when start request removed\n            IF NOT Start_Request THEN\n                state := 1;\n                Handshake_Fault := FALSE;\n            ELSE\n                // if still requested, remain in COMPLETE waiting for clear\n                state := 6;\n            END_IF;\n\n        7: // FAULT\n            HS_State.SubState := 'FAULT';\n            Transfer_StartCmd := FALSE;\n            Handshake_Fault := TRUE;\n            // Requires manual clear: wait for Start_Request to be cleared\n            IF NOT Start_Request THEN\n                state := 8; // ABORT cleanup\n            END_IF;\n\n        8: // ABORT\n            HS_State.SubState := 'ABORT';\n            Transfer_StartCmd := FALSE;\n            transferWD(IN := FALSE, PT := transferTimeout);\n            handshakeWD(IN := FALSE, PT := handshakeTimeout);\n            completionTD(IN := FALSE, PT := completionDelay);\n            // Reset retries and fault once Start_Request cleared\n            IF NOT Start_Request THEN\n                Handshake_Fault := FALSE;\n                retriesLeft := retriesMax;\n                state := 1;\n            END_IF;\n\n        ELSE\n            // Unknown - safe fallback to IDLE\n            state := 1;\n    END_CASE;\n\n    // Export retry count\n    Retry_Count := UINT(retriesLeft);\n\n    // Populate simple HS_State.ModeName for SCADA\n    HS_State.ModeName := 'PALLETIZER_HS';\n    HS_State.LastTransitionTS := HS_State.LastTransitionTS + 1; // pseudo-time tick for diagnostics\n\n    startPrev := Start_Request;\nEND_FUNCTION_BLOCK"
    },
    {
      "relpath": "DB/DB_Conveyor1.scl",
      "reason": "Instance DB for the conveyor FB must exist and be named explicitly (DB_Conveyor1) per developer rules.",
      "new_content": "DATA_BLOCK DB_Conveyor1\nVAR\n    Instance : FB_Conveyor; // Instance DB for conveyor 1 - public variables are accessible for SCADA mapping\nEND_VAR\nEND_DATA_BLOCK"
    },
    {
      "relpath": "DB/DB_MergeDivert.scl",
      "reason": "Instance DB for the Merge/Divert FB must exist and be named explicitly (DB_MergeDivert).",
      "new_content": "DATA_BLOCK DB_MergeDivert\nVAR\n    Instance : FB_MergeDivert; // Instance DB for merge/divert logic\nEND_VAR\nEND_DATA_BLOCK"
    },
    {
      "relpath": "DB/DB_PalletizerHS.scl",
      "reason": "Instance DB for the palletizer handshake FB must exist and be named DB_PalletizerHS per checklist.",
      "new_content": "DATA_BLOCK DB_PalletizerHS\nVAR\n    Instance : FB_PalletizerHS; // Instance DB for palletizer handshake FB\nEND_VAR\nEND_DATA_BLOCK"
    },
    {
      "relpath": "OB/OB100.scl",
      "reason": "Provide a dedicated OB100 cold-start initialization that initializes all FB instance DB defaults, clears non-latched diagnostics where permitted, and enforces ESTOP safe state at power-up as required in checklist.",
      "new_content": "ORGANIZATION_BLOCK OB100\n// Cold-start initialization: deterministic safe defaults, initialize instance DBs and latch critical alarms if ESTOP asserted.\nBEGIN\n    // Initialize Comms DB (if present)\n    IF DB_Comms.Instance.CPU_Heartbeat_TS = 0 THEN\n        DB_Comms.Instance.CPU_Heartbeat_TS := 0;\n        DB_Comms.Instance.HSBY_HB_TS := 0;\n        DB_Comms.Instance.Heartbeat_Fault := FALSE;\n    END_IF;\n\n    // Diagnostics request a one-shot update to populate DB_Diag with default values\n    DB_Diag.Instance.Request_Update := TRUE;\n    DB_Diag.Instance();\n\n    // Initialize Mode Manager: default to STOP safe state until operator issues RUN\n    DB_ModeMgr.Instance.Req_CommandStop := TRUE;\n    DB_ModeMgr.Instance.Req_CommandRun := FALSE;\n    DB_ModeMgr.Instance.Req_SimulationEnable := FALSE;\n    DB_ModeMgr.Instance.HsbyLinkHealthy := TRUE;\n    DB_ModeMgr.Instance.RemoteRacksOk := TRUE;\n    DB_ModeMgr.Instance.TimeSyncOk := TRUE;\n    DB_ModeMgr.Instance.EstopActive := FALSE;\n    DB_ModeMgr.Instance();\n\n    // Initialize Alarm Manager: ensure no stale requests, but keep historical latched alarms if retentive policy requires\n    DB_AlarmMgr.Instance.Req_SetAlarm := FALSE;\n    DB_AlarmMgr.Instance.Req_AckAlarm := FALSE;\n    DB_AlarmMgr.Instance.Req_ClearAlarm := FALSE;\n    DB_AlarmMgr.Instance();\n\n    // Initialize Conveyor instance DB defaults\n    DB_Conveyor1.Instance.Drive_Enable := FALSE;\n    DB_Conveyor1.Instance.Jam_Detected := FALSE;\n    DB_Conveyor1.Instance.Occupant_Count := 0;\n    DB_Conveyor1.Instance.Fault := FALSE;\n\n    // Initialize MergeDivert DB\n    DB_MergeDivert.Instance.RouteCmd := '';\n    DB_MergeDivert.Instance.HoldCmd := FALSE;\n    DB_MergeDivert.Instance.Alarm_RoutingMissing := FALSE;\n\n    // Initialize Palletizer DB\n    DB_PalletizerHS.Instance.HS_State.ModeName := 'PALLETIZER_HS';\n    DB_PalletizerHS.Instance.Handshake_Fault := FALSE;\n    DB_PalletizerHS.Instance.Transfer_StartCmd := FALSE;\n    DB_PalletizerHS.Instance.Retry_Count := 0;\n\n    // If ESTOP (safety chain) is asserted at power-up, latch critical alarms and enforce safe state\n    IF DB_ModeMgr.Instance.EstopActive THEN\n        // Latch a conservative startup critical alarm\n        DB_AlarmMgr.Instance.Req_SetAlarm := TRUE;\n        DB_AlarmMgr.Instance.Req_AlarmID := 'ALM_CPU_FAULT';\n        DB_AlarmMgr.Instance.Req_Severity := 'critical';\n        DB_AlarmMgr.Instance.Req_Description := 'ESTOP asserted at cold start - system starts in HALT';\n        DB_AlarmMgr.Instance.Req_Latched := TRUE;\n        DB_AlarmMgr.Instance();\n    END_IF;\nEND_ORGANIZATION_BLOCK"
    },
    {
      "relpath": "OB/OB1.scl",
      "reason": "Provide a dedicated OB1 cyclic task that calls ModeMgr, all FB instances (including newly added conveyor/merge/divert/palletizer), alarm/diag/comms each cycle, and the SCADA Tag Map FC per the checklist.",
      "new_content": "ORGANIZATION_BLOCK OB1\n// Main cyclic (MAST) task: executes ModeMgr, all FB instances, Alarm/Diag/Comms and user FBs each cycle.\nVAR\n    localEstop : BOOL;\nEND_VAR\nBEGIN\n    // Evaluate authoritative ESTOP flag from ModeMgr instance\n    localEstop := DB_ModeMgr.Instance.EstopActive;\n\n    // Execute Mode Manager first to determine permissives for this cycle\n    DB_ModeMgr.Instance();\n\n    // Execute safety relevant FBs with ESTOP applied\n    // Comms (heartbeat) must know ESTOP to suppress heartbeats\n    DB_Comms.Instance.EstopActive := localEstop;\n    DB_Comms.Instance();\n\n    // Diagnostics aggregation\n    DB_Diag.Instance.Request_Update := TRUE;\n    DB_Diag.Instance();\n\n    // Alarm manager: process any set/ack/clear requests from other FBs\n    DB_AlarmMgr.Instance();\n\n    // Conveyor instance(s) - single conveyor instance DB_Conveyor1 in this deliverable\n    // Application should map hardware DI/Enc into DB_Conveyor1.Instance inputs prior to call\n    DB_Conveyor1.Instance();\n\n    // Merge/Divert instance\n    DB_MergeDivert.Instance();\n\n    // Palletizer handshake instance\n    DB_PalletizerHS.Instance();\n\n    // Refresh SCADA Tag Map documentation DB each cycle (idempotent)\n    FC_Scada_Tag_Map();\nEND_ORGANIZATION_BLOCK"
    }
  ]
}