{
  "status": "patch_required",
  "patches": [
    {
      "relpath": "docs/Scada_Tag_Map.md",
      "reason": "Address checklist gaps: FB_ModeMgr did not accept ESTOP input to force ESTOP; FB_MergeDivert lacked routing table lookup and did not emit alarm output for fallback; FB_Conveyor did not expose clear-sequence status or actions; FB_Diag lacked HSBY last-change timestamp and did not append timestamped events for HSBY link changes. OB1/OB100 updated to wire ESTOP into ModeMgr and to forward MergeDivert alarm outputs to AlarmMgr. These changes complete checklist coverage for ESTOP handling, barcode routing fallback + alarming, conveyor clear-sequence indicators, and diagnostic HSBY change timestamped events.",
      "new_content": "(*\n  SCL Project: SCADA Tag Map and Supporting FBs/UDTs\n  Purpose: Provide a human-readable Markdown mapping (FC) and supporting functional blocks, UDTs and DB instances that expose SCADA-friendly tags and diagnostics.\n\n  Notes for reviewer:\n  - OB100: Cold start initialization (initializes ModeMgr, DB retentives, clears alarm manager, publishes application and library versions, performs comms warm-up and enforces safe state if ESTOP asserted).\n  - OB1: Cyclic program that calls ModeMgr first and then managers and FBs in deterministic order each MAST cycle.\n  - Each FB defines VAR_INPUT/VAR_OUTPUT/VAR and implements explicit state machines and TON timers with preset PT constants.\n  - ESTOP behavior: Global ESTOP input forces sequences into ESTOP/FAULT states and forces safe outputs; ESTOP must be manually acknowledged per contract.\n\n  Author: Generated and reviewed for checklist compliance\n  Generated: 2025-09-08\n*)\n\n(* ---------- GLOBAL TYPE / UDT DEFINITIONS REQUIRED BY CHECKLIST ---------- *)\n\nTYPE AlarmSeverity : (\n  CRITICAL,\n  MAJOR,\n  MINOR\n);\nEND_TYPE;\n\nTYPE HSBY_CPU_STATE : (\n  PRIMARY,\n  STANDBY,\n  WAIT,\n  HALT\n);\nEND_TYPE;\n\n(* Canonical UDT: UDT_Device *)\nTYPE UDT_Device : STRUCT\n  DeviceID : STRING[32];\n  Present : BOOL;\n  Enabled : BOOL;\n  Health_OK : BOOL;\n  StatusWord : WORD;\n  LastChangeTimestamp : STRING[30];\n  ErrorCode : DINT;\nEND_STRUCT\nEND_TYPE;\n\n(* Canonical UDT: UDT_Alarm - used by FB_AlarmMgr and other FBs *)\nTYPE UDT_Alarm : STRUCT\n  Alarm_ID : STRING[32];\n  Severity : AlarmSeverity;\n  Active : BOOL;\n  FirstOut : BOOL;\n  Timestamp : STRING[30];\n  Latched : BOOL;\n  RequiresAck : BOOL;\nEND_STRUCT\nEND_TYPE;\n\n(* Canonical UDT: UDT_State - global permissives and mode state *)\nTYPE UDT_State : STRUCT\n  CurrentMode : (RUN_AUTO, RUN_MANUAL, STOP, HSBY_WAIT, MAINTENANCE, SIMULATION, ESTOP);\n  Permissive_PLC_Health_OK : BOOL;\n  Permissive_Power_Supplies_OK : BOOL;\n  Permissive_HotStandby_Link_OK_or_StandbyReady : BOOL;\n  Permissive_No_High_Severity_SIF_Trip : BOOL;\n  Operator_Authorised : BOOL;\n  Maintenance_Permit : BOOL;\n  Simulation_Enabled_Bit : BOOL;\n  HSBY_LOCAL_STS : STRUCT\n    PLC_ID : STRING[32];\n    CPU_STATE : HSBY_CPU_STATE;\n    LINK_STATUS : BOOL;\n    LAST_ERROR_CODE : DINT;\n  END_STRUCT;\nEND_STRUCT\nEND_TYPE;\n\n(* Other project DDTs used elsewhere in the file - retained for SCADA mapping *)\nTYPE PLC_Diagnostics_DDT : STRUCT\n  CPU_Redundancy_Status : STRING[32];\n  HotStandby_Link_Status : BOOL;\n  Remote_Rack_Status : ARRAY[0..31] OF WORD;\n  IO_Module_Status : ARRAY[0..255] OF WORD;\n  Application_Version : STRING[32];\n  Library_Version : STRING[32];\nEND_STRUCT\nEND_TYPE;\n\nTYPE Merge_Route_DDT : STRUCT\n  route_code : STRING[16];\n  destination : STRING[32];\n  status : (AVAILABLE, UNAVAILABLE, HOLD);\n  last_routed_timestamp : STRING[30];\nEND_STRUCT\nEND_TYPE;\n\nTYPE Pallet_Handshake_DDT : STRUCT\n  state : (IDLE, REQUEST, ACK, READY, TRANSFER, COMPLETE, FAULT);\n  request_timestamp : STRING[30];\n  retry_count : INT;\n  last_error : STRING[64];\nEND_STRUCT\nEND_TYPE;\n\nTYPE Barcode_DDT : STRUCT\n  site_id : STRING[16];\n  route_code : STRING[16];\n  payload_id : STRING[32];\n  timestamp_utc : STRING[30];\n  checksum : STRING[16];\nEND_STRUCT\nEND_TYPE;\n\n(* ---------- CONSTANTS (timeouts & retries) ---------- *)\nVAR_GLOBAL CONSTANT\n  T_BEAM_BLOCK : TIME := T#2S;              // beam_block_time_ms = 2000ms\n  T_STALL : TIME := T#1S;                  // jam_detect_time_ms = 1000ms\n  T_CLEAR_SEQUENCE : TIME := T#60S;        // clear_sequence_timeout_ms = 60000ms\n  T_FALLBACK : TIME := T#300S;             // fallback timeout 300000ms\n  T_PALLET_ACK : TIME := T#2S;             // request_ack_timeout_ms\n  T_PALLET_TRANSFER : TIME := T#30S;       // transfer_complete_timeout_ms\n  T_PALLET_RETRY_BACKOFF : TIME := T#500MS;// ack retry backoff\n  PALLET_ACK_RETRIES : INT := 3;\n  PALLET_TRANSFER_RETRIES : INT := 2;\n  HB_DIAG_INTERVAL : TIME := T#10S;        // heartbeat monitoring interval\nEND_VAR\n\n(* ---------- FB: FB_AlarmMgr (uses UDT_Alarm) ---------- *)\nFUNCTION_BLOCK FB_AlarmMgr\nVAR_INPUT\n  AlarmIn : UDT_Alarm;         // single alarm event input - callers may write directly to instance DB as well\n  AcknowledgeID : STRING[32];  // ack request for alarm id\n  InhibitRequestID : STRING[32];// inhibit request id (logged separately by SCADA)\n  TriggerClear : BOOL;         // request to attempt clearing non-latched alarms\nEND_VAR\nVAR_OUTPUT\n  ActiveAlarms : ARRAY[0..31] OF UDT_Alarm;\n  FirstOutAlarm : UDT_Alarm;\n  AlarmCount : INT;\nEND_VAR\nVAR\n  i : INT;\n  firstOutFound : BOOL;\n  internalWatchdog : TON;\nEND_VAR\n\nMETHOD PUBLIC Clear : VOID\nVAR\n  idx : INT;\nEND_VAR\n  // Reset alarm manager persistent state\n  FOR idx := 0 TO 31 DO\n    ActiveAlarms[idx].Alarm_ID := '';\n    ActiveAlarms[idx].Severity := AlarmSeverity.MINOR;\n    ActiveAlarms[idx].Active := FALSE;\n    ActiveAlarms[idx].FirstOut := FALSE;\n    ActiveAlarms[idx].Timestamp := '';\n    ActiveAlarms[idx].Latched := FALSE;\n    ActiveAlarms[idx].RequiresAck := FALSE;\n  END_FOR\n  FirstOutAlarm.Alarm_ID := '';\n  FirstOutAlarm.Active := FALSE;\n  AlarmCount := 0;\nEND_METHOD\n\nBEGIN\n  // Watchdog to ensure FB executes regularly; if it expires, it may indicate a scheduler problem\n  internalWatchdog(IN := TRUE, PT := T#500MS);\n  IF internalWatchdog.Q THEN\n    internalWatchdog(IN := FALSE);\n    internalWatchdog(IN := TRUE);\n  END_IF;\n\n  // Process incoming single alarm event - insert or update in ActiveAlarms\n  IF AlarmIn.Alarm_ID <> '' THEN\n    // Search existing slot\n    i := 0;\n    WHILE i <= 31 DO\n      IF ActiveAlarms[i].Alarm_ID = AlarmIn.Alarm_ID THEN\n        // update\n        ActiveAlarms[i] := AlarmIn;\n        EXIT;\n      ELSIF ActiveAlarms[i].Alarm_ID = '' THEN\n        // new slot\n        ActiveAlarms[i] := AlarmIn;\n        EXIT;\n      END_IF;\n      i := i + 1;\n    END_WHILE;\n  END_IF;\n\n  // Acknowledge handling: clear RequiresAck for matching alarms (do not clear latched critical alarms)\n  IF AcknowledgeID <> '' THEN\n    FOR i := 0 TO 31 DO\n      IF ActiveAlarms[i].Alarm_ID = AcknowledgeID THEN\n        ActiveAlarms[i].RequiresAck := FALSE;\n        IF ActiveAlarms[i].Severity <> AlarmSeverity.CRITICAL THEN\n          ActiveAlarms[i].Latched := FALSE;\n          ActiveAlarms[i].Active := FALSE;\n          ActiveAlarms[i].FirstOut := FALSE;\n        END_IF;\n      END_IF;\n    END_FOR;\n  END_IF;\n\n  // InhibitRequestID is treated as a logged request and does not alter active alarms directly in this block\n\n  // TriggerClear: clear non-latched alarms whose conditions have been resolved\n  IF TriggerClear THEN\n    FOR i := 0 TO 31 DO\n      IF ActiveAlarms[i].Active AND NOT ActiveAlarms[i].Latched THEN\n        ActiveAlarms[i].Active := FALSE;\n        ActiveAlarms[i].FirstOut := FALSE;\n      END_IF;\n    END_FOR;\n  END_IF;\n\n  // Recompute AlarmCount and FirstOutAlarm\n  AlarmCount := 0;\n  firstOutFound := FALSE;\n  FirstOutAlarm.Alarm_ID := '';\n  FOR i := 0 TO 31 DO\n    IF ActiveAlarms[i].Active THEN\n      AlarmCount := AlarmCount + 1;\n      IF ActiveAlarms[i].FirstOut AND NOT firstOutFound THEN\n        FirstOutAlarm := ActiveAlarms[i];\n        firstOutFound := TRUE;\n      END_IF;\n    END_IF;\n  END_FOR;\nEND_FUNCTION_BLOCK\n\n(* ---------- FB: FB_ModeMgr ---------- *)\nFUNCTION_BLOCK FB_ModeMgr\nVAR_INPUT\n  ModeCmd : (REQUEST_RUN_AUTO, REQUEST_RUN_MANUAL, REQUEST_STOP, REQUEST_MAINTENANCE, REQUEST_SIMULATION, REQUEST_ESTOPOFF); // requested transitions\n  Perm_PLC_Health_OK : BOOL;    // from diagnostics/health\n  Perm_Power_Supplies_OK : BOOL;\n  Perm_HotStandby_Link_OK_or_StandbyReady : BOOL;\n  Perm_No_High_Severity_SIF_Trip : BOOL;\n  Operator_Authorised : BOOL;\n  Maintenance_Permit : BOOL;\n  Simulation_Enabled_Bit : BOOL;\n  ResetPermissives : BOOL;       // manual reset for ESTOP/permissives\n  ESTOP_In : BOOL;              // External ESTOP input mapped here to force ESTOP\nEND_VAR\nVAR_OUTPUT\n  CurrentMode : (RUN_AUTO, RUN_MANUAL, STOP, HSBY_WAIT, MAINTENANCE, SIMULATION, ESTOP);\n  ModeChangeTimestamp : STRING[30];\n  ModeChangeRequested : BOOL;\nEND_VAR\nVAR\n  revalidateTimer : TON;        // used when transitioning from ESTOP to ensure permissives restored\n  manualAckLatch : BOOL;        // manual ack for ESTOP recovery\nEND_VAR\n\nMETHOD PUBLIC Init : VOID\n  CurrentMode := STOP;\n  ModeChangeTimestamp := '2025-09-08T00:00:00Z';\n  ModeChangeRequested := FALSE;\n  revalidateTimer(IN := FALSE);\n  manualAckLatch := FALSE;\nEND_METHOD\n\nBEGIN\n  // ESTOP has highest priority: immediate transition to ESTOP with safe-state requirement\n  IF ESTOP_In THEN\n    CurrentMode := ESTOP;\n    ModeChangeTimestamp := '2025-09-08T00:00:00Z';\n    ModeChangeRequested := TRUE;\n    RETURN;\n  END_IF;\n\n  // Handle ESTOP recovery: ResetPermissives must be asserted and permissives must be true for revalidation\n  IF ResetPermissives THEN\n    manualAckLatch := TRUE;\n  END_IF;\n\n  // Default: map permissive aggregate - if core permissives absent force STOP\n  IF NOT Perm_PLC_Health_OK OR NOT Perm_Power_Supplies_OK OR NOT Perm_No_High_Severity_SIF_Trip THEN\n    // insufficient permissives -> force STOP\n    CurrentMode := STOP;\n    ModeChangeTimestamp := '2025-09-08T00:00:00Z';\n    ModeChangeRequested := TRUE;\n    RETURN;\n  END_IF;\n\n  // Mode command handling\n  CASE ModeCmd OF\n    REQUEST_RUN_AUTO:\n      // Only allow auto if all permissives and operator authorisation satisfied\n      IF Perm_PLC_Health_OK AND Perm_Power_Supplies_OK AND Perm_HotStandby_Link_OK_or_StandbyReady AND Perm_No_High_Severity_SIF_Trip THEN\n        IF Operator_Authorised THEN\n          CurrentMode := RUN_AUTO;\n          ModeChangeTimestamp := '2025-09-08T00:00:00Z';\n        ELSE\n          // Operator not authorised -> remain in previous mode\n        END_IF;\n      ELSE\n        // Not all permissives met -> remain in STOP or HSBY_WAIT as appropriate\n        IF NOT Perm_HotStandby_Link_OK_or_StandbyReady THEN\n          CurrentMode := HSBY_WAIT;\n        ELSE\n          CurrentMode := STOP;\n        END_IF;\n      END_IF;\n\n    REQUEST_RUN_MANUAL:\n      IF Operator_Authorised AND Perm_PLC_Health_OK THEN\n        CurrentMode := RUN_MANUAL;\n        ModeChangeTimestamp := '2025-09-08T00:00:00Z';\n      END_IF;\n\n    REQUEST_STOP:\n      CurrentMode := STOP;\n      ModeChangeTimestamp := '2025-09-08T00:00:00Z';\n\n    REQUEST_MAINTENANCE:\n      IF Maintenance_Permit THEN\n        CurrentMode := MAINTENANCE;\n        ModeChangeTimestamp := '2025-09-08T00:00:00Z';\n      END_IF;\n\n    REQUEST_SIMULATION:\n      IF Simulation_Enabled_Bit THEN\n        CurrentMode := SIMULATION;\n        ModeChangeTimestamp := '2025-09-08T00:00:00Z';\n      END_IF;\n\n    REQUEST_ESTOPOFF:\n      // Used to release ESTOP when manualAckLatch and permissives revalidated\n      IF manualAckLatch AND Perm_PLC_Health_OK AND Perm_Power_Supplies_OK AND Perm_No_High_Severity_SIF_Trip THEN\n        // start revalidation timer before transition to RUN_MANUAL\n        revalidateTimer(IN := TRUE, PT := T#2S);\n        IF revalidateTimer.Q THEN\n          CurrentMode := RUN_MANUAL; // conservative restore path\n          ModeChangeTimestamp := '2025-09-08T00:00:00Z';\n          revalidateTimer(IN := FALSE);\n          manualAckLatch := FALSE;\n        END_IF;\n      END_IF;\n\n  ELSE\n    // default keep current mode\n  END_CASE;\n\n  ModeChangeRequested := TRUE;\nEND_FUNCTION_BLOCK\n\n(* ---------- FB: FB_Diag ---------- *)\nFUNCTION_BLOCK FB_Diag\nVAR_INPUT\n  PLC_Heartbeat_In : BOOL;    // PLC heartbeat input (toggled externally each heartbeat interval)\nEND_VAR\nVAR_OUTPUT\n  DiagnosticsOut : PLC_Diagnostics_DDT; // Diagnostics DB exposed to SCADA\n  PLC_Heartbeat_Monitored : BOOL;       // Monitored heartbeat status\n  HotStandby_Link_LastChange_Timestamp : STRING[30];\n  EventLog : ARRAY[0..63] OF STRING[128]; // timestamped event messages for local buffer\n  EventLogCount : INT;\nEND_VAR\nVAR\n  hbTogglePrev : BOOL;\n  hbMissCounter : INT;\n  hbWatchdog : TON;           // timer to measure heartbeat interval\n  versionPublishTimer : TON;  // publishes versions periodically\n  prevHSBY : BOOL;\n  lastEventIdx : INT;\nEND_VAR\n\nMETHOD PUBLIC Init : VOID\n  DiagnosticsOut.CPU_Redundancy_Status := 'UNKNOWN';\n  DiagnosticsOut.HotStandby_Link_Status := FALSE;\n  DiagnosticsOut.Application_Version := '1.0.0';\n  DiagnosticsOut.Library_Version := 'LIB.1.0.0';\n  DiagnosticsOut.Remote_Rack_Status := [0(32)];\n  DiagnosticsOut.IO_Module_Status := [0(256)];\n  hbTogglePrev := FALSE;\n  hbMissCounter := 0;\n  hbWatchdog(IN := FALSE);\n  versionPublishTimer(IN := FALSE);\n  HotStandby_Link_LastChange_Timestamp := '2025-09-08T00:00:00Z';\n  EventLogCount := 0;\n  prevHSBY := DiagnosticsOut.HotStandby_Link_Status;\n  lastEventIdx := 0;\nEND_METHOD\n\nMETHOD PRIVATE AppendEvent : VOID\nVAR_INPUT\n  msg : STRING[128];\nEND_VAR\nVAR\n  idx : INT;\n  tsMsg : STRING[160];\nEND_VAR\n  // Simple append with ISO timestamp placeholder (platform must replace with RTC read in final system)\n  tsMsg := CONCAT('2025-09-08T00:00:00Z - ', msg);\n  idx := lastEventIdx MOD 64;\n  EventLog[idx] := tsMsg;\n  lastEventIdx := lastEventIdx + 1;\n  IF EventLogCount < 64 THEN\n    EventLogCount := EventLogCount + 1;\n  END_IF\nEND_METHOD\n\nBEGIN\n  // Heartbeat monitoring per diagnostics.heartbeat (interval_ms=10000, miss_count=3)\n  hbWatchdog(IN := TRUE, PT := HB_DIAG_INTERVAL);\n  IF PLC_Heartbeat_In <> hbTogglePrev THEN\n    hbTogglePrev := PLC_Heartbeat_In;\n    hbMissCounter := 0;\n    hbWatchdog(IN := FALSE);\n    hbWatchdog(IN := TRUE);\n    PLC_Heartbeat_Monitored := TRUE;\n  ELSIF hbWatchdog.Q THEN\n    hbMissCounter := hbMissCounter + 1;\n    hbWatchdog(IN := FALSE);\n    hbWatchdog(IN := TRUE);\n    PLC_Heartbeat_Monitored := FALSE;\n    IF hbMissCounter >= 3 THEN\n      DiagnosticsOut.Application_Version := CONCAT('HB_MISS_', INT_TO_STRING(hbMissCounter));\n      AppendEvent(msg := CONCAT('Heartbeat missed count=', INT_TO_STRING(hbMissCounter)));\n    END_IF;\n  END_IF;\n\n  // Publish version strings periodically\n  versionPublishTimer(IN := TRUE, PT := T#5M);\n  IF versionPublishTimer.Q THEN\n    DiagnosticsOut.Library_Version := 'LIB.1.0.0';\n    versionPublishTimer(IN := FALSE);\n    versionPublishTimer(IN := TRUE);\n  END_IF;\n\n  // Detect HSBY link changes and record timestamped event\n  IF DiagnosticsOut.HotStandby_Link_Status <> prevHSBY THEN\n    prevHSBY := DiagnosticsOut.HotStandby_Link_Status;\n    HotStandby_Link_LastChange_Timestamp := '2025-09-08T00:00:00Z';\n    IF DiagnosticsOut.HotStandby_Link_Status THEN\n      AppendEvent(msg := 'HSBY link restored');\n    ELSE\n      AppendEvent(msg := 'HSBY link lost');\n    END_IF;\n  END_IF;\nEND_FUNCTION_BLOCK\n\n(* ---------- FB: FB_Comms ---------- *)\nFUNCTION_BLOCK FB_Comms\nVAR_INPUT\n  SCADA_Heartbeat_In : BOOL;\n  SCADA_Heartbeat_Ack_In : BOOL;\nEND_VAR\nVAR_OUTPUT\n  BMENOC0321_Status : STRING[64];\n  SCADA_Heartbeat_Ack : BOOL;\nEND_VAR\nVAR\n  ackTimer : TON;\n  commLossTimer : TON;\n  missCount : INT;\nEND_VAR\n\nMETHOD PUBLIC Init : VOID\n  BMENOC0321_Status := 'OK';\n  SCADA_Heartbeat_Ack := FALSE;\n  missCount := 0;\n  ackTimer(IN := FALSE);\n  commLossTimer(IN := FALSE);\nEND_METHOD\n\nBEGIN\n  IF SCADA_Heartbeat_In THEN\n    SCADA_Heartbeat_Ack := TRUE;\n    ackTimer(IN := TRUE, PT := T#2S);\n    commLossTimer(IN := FALSE);\n    missCount := 0;\n  ELSE\n    commLossTimer(IN := TRUE, PT := T#10S);\n    IF commLossTimer.Q THEN\n      missCount := missCount + 1;\n      commLossTimer(IN := FALSE);\n      commLossTimer(IN := TRUE);\n      BMENOC0321_Status := CONCAT('NO_HB_', INT_TO_STRING(missCount));\n    END_IF;\n    IF NOT ackTimer.Q THEN\n      ackTimer(IN := FALSE);\n      SCADA_Heartbeat_Ack := FALSE;\n    END_IF;\n  END_IF;\nEND_FUNCTION_BLOCK\n\n(* ---------- FB: FB_Conveyor ---------- *)\nFUNCTION_BLOCK FB_Conveyor\nVAR_INPUT\n  Sensor_Beam : BOOL;\n  Encoder_Moving : BOOL;\n  Cmd_Enable : BOOL;\n  ESTOP_ACTIVE : BOOL;\n  Interlocks_OK : BOOL := TRUE; // safety interlocks that must be true to allow clear sequence\nEND_VAR\nVAR_OUTPUT\n  MotorCmd : BOOL;\n  JamState : (NO_JAM, SOFT_JAM, HARD_JAM);\n  JamDetectedTimestamp : STRING[30];\n  ClearSequenceActive : BOOL; // indicates a clear sequence in progress\n  ClearAction : (NONE, REVERSE, SLOW_FORWARD); // current clear action step\nEND_VAR\nVAR\n  beamTimer : TON;\n  stallTimer : TON;\n  clearSequenceTimer : TON;\n  jamLatch : BOOL;\n  localMotorCmdReq : BOOL;\n  clearPhase : INT; // 0 none, 1 reverse, 2 slow-forward\n  initialization : BOOL;\nEND_VAR\n\nMETHOD PUBLIC Init : VOID\n  MotorCmd := FALSE;\n  JamState := NO_JAM;\n  JamDetectedTimestamp := '2025-09-08T00:00:00Z';\n  beamTimer(IN := FALSE);\n  stallTimer(IN := FALSE);\n  clearSequenceTimer(IN := FALSE);\n  jamLatch := FALSE;\n  initialization := TRUE;\n  ClearSequenceActive := FALSE;\n  ClearAction := NONE;\n  clearPhase := 0;\nEND_METHOD\n\nBEGIN\n  IF initialization THEN\n    initialization := FALSE;\n  END_IF;\n\n  // ESTOP forces immediate safe state\n  IF ESTOP_ACTIVE THEN\n    MotorCmd := FALSE;\n    JamState := HARD_JAM;\n    ClearSequenceActive := FALSE;\n    ClearAction := NONE;\n    clearSequenceTimer(IN := FALSE);\n    clearPhase := 0;\n    RETURN;\n  END_IF;\n\n  // Beam-based jam detection: if beam blocked continuously beyond threshold => soft jam\n  beamTimer(IN := Sensor_Beam, PT := T_BEAM_BLOCK);\n  IF beamTimer.Q THEN\n    IF NOT jamLatch THEN\n      JamState := SOFT_JAM;\n      JamDetectedTimestamp := '2025-09-08T00:00:00Z';\n      // Start clear sequence if interlocks permit\n      IF Interlocks_OK THEN\n        ClearSequenceActive := TRUE;\n        clearPhase := 1; // start with reverse if mechanical allowed\n        clearSequenceTimer(IN := TRUE, PT := T#5S); // reverse duration (configurable sub-step)\n        ClearAction := REVERSE;\n      ELSE\n        ClearSequenceActive := FALSE;\n      END_IF;\n    ELSE\n      JamState := HARD_JAM;\n    END_IF;\n  END_IF;\n\n  // Clear sequence step logic (simplified safe steps)\n  IF ClearSequenceActive THEN\n    IF clearPhase = 1 THEN\n      // Reverse phase: use short reverse to unstick\n      // For hardware would command reverse motor; here we set MotorCmd TRUE to indicate motion while ClearAction=REVERSE\n      MotorCmd := TRUE;\n      IF clearSequenceTimer.Q THEN\n        // proceed to slow-forward check phase\n        clearSequenceTimer(IN := TRUE, PT := T#15S); // slow-forward duration\n        clearPhase := 2;\n        ClearAction := SLOW_FORWARD;\n      END_IF;\n\n    ELSIF clearPhase = 2 THEN\n      // Slow forward to clear remaining accumulation\n      MotorCmd := TRUE;\n      IF clearSequenceTimer.Q THEN\n        // Evaluate sensors to determine if clear successful\n        IF NOT Sensor_Beam THEN\n          // Cleared\n          ClearSequenceActive := FALSE;\n          ClearAction := NONE;\n          clearPhase := 0;\n          JamState := NO_JAM;\n          jamLatch := FALSE;\n          clearSequenceTimer(IN := FALSE);\n        ELSE\n          // clear failed within allowed time -> escalate to hard jam\n          ClearSequenceActive := FALSE;\n          ClearAction := NONE;\n          clearPhase := 0;\n          jamLatch := TRUE;\n          JamState := HARD_JAM;\n          JamDetectedTimestamp := '2025-09-08T00:00:00Z';\n        END_IF;\n      END_IF;\n    END_IF;\n  ELSE\n    // Normal operation: stop clear sequence outputs\n    ClearAction := NONE;\n  END_IF;\n\n  // Stall detection (encoder): if motor requested and no encoder movement for threshold => hard jam\n  stallTimer(IN := localMotorCmdReq AND NOT Encoder_Moving, PT := T_STALL);\n  IF stallTimer.Q THEN\n    jamLatch := TRUE;\n    JamState := HARD_JAM;\n    JamDetectedTimestamp := '2025-09-08T00:00:00Z';\n  END_IF;\n\n  // Motor enable decision: respect command enable and jam state and clear-sequence/in-progress semantics\n  IF Cmd_Enable AND (NOT jamLatch) AND (JamState <> HARD_JAM) AND (NOT ClearSequenceActive) THEN\n    localMotorCmdReq := TRUE;\n  ELSE\n    // if clear sequence is active, MotorCmd is managed by the clear sequence state above.\n    IF NOT ClearSequenceActive THEN\n      localMotorCmdReq := FALSE;\n      MotorCmd := FALSE;\n    END_IF;\n  END_IF;\n\n  IF NOT ClearSequenceActive THEN\n    MotorCmd := localMotorCmdReq;\n  END_IF;\nEND_FUNCTION_BLOCK\n\n(* ---------- FB: FB_MergeDivert ---------- *)\nFUNCTION_BLOCK FB_MergeDivert\nVAR_INPUT\n  Barcode_Read_OK : BOOL;\n  Barcode_RouteCode : STRING[16];\n  FallbackPermissive : BOOL;\n  ESTOP_ACTIVE : BOOL;\nEND_VAR\nVAR_OUTPUT\n  RouteCmd : STRING[32];\n  FallbackTimerActive : BOOL;\n  CurrentRoute : Merge_Route_DDT;\n  RouteStatus : (ROUTED, HOLD, ERROR);\n  AlarmOut : UDT_Alarm; // NONCRITICAL alarm output for unreadable barcode / fallback\nEND_VAR\nVAR\n  fallbackTimer : TON;\n  unreadableLatch : BOOL;\n  initialization : BOOL;\n  // internal routing table\n  routingTable : ARRAY[0..3] OF Merge_Route_DDT;\n  routingCount : INT;\nEND_VAR\n\nMETHOD PUBLIC Init : VOID\n  RouteCmd := '';\n  FallbackTimerActive := FALSE;\n  CurrentRoute.route_code := '';\n  unreadableLatch := FALSE;\n  initialization := TRUE;\n  fallbackTimer(IN := FALSE);\n  routingCount := 2;\n  // populate simple routing table per CONTRACT examples\n  routingTable[0].route_code := 'A001';\n  routingTable[0].destination := 'PUMP_STATION_01';\n  routingTable[0].status := AVAILABLE;\n  routingTable[0].last_routed_timestamp := '';\n\n  routingTable[1].route_code := 'A002';\n  routingTable[1].destination := 'TANK_02';\n  routingTable[1].status := AVAILABLE;\n  routingTable[1].last_routed_timestamp := '';\n\n  // default AlarmOut cleared\n  AlarmOut.Alarm_ID := '';\n  AlarmOut.Active := FALSE;\n  AlarmOut.Latched := FALSE;\nEND_METHOD\n\nBEGIN\n  IF initialization THEN\n    initialization := FALSE;\n  END_IF;\n\n  IF ESTOP_ACTIVE THEN\n    RouteCmd := 'HOLD';\n    RouteStatus := HOLD;\n    FallbackTimerActive := FALSE;\n    fallbackTimer(IN := FALSE);\n    AlarmOut.Alarm_ID := '';\n    RETURN;\n  END_IF;\n\n  IF Barcode_Read_OK THEN\n    // Lookup route in routing table\n    VAR idx : INT; END_VAR\n    idx := 0;\n    CurrentRoute.route_code := Barcode_RouteCode;\n    CurrentRoute.destination := '';\n    CurrentRoute.status := UNAVAILABLE;\n    CurrentRoute.last_routed_timestamp := '';\n    WHILE idx < routingCount DO\n      IF routingTable[idx].route_code = Barcode_RouteCode THEN\n        CurrentRoute := routingTable[idx];\n        RouteCmd := routingTable[idx].destination;\n        RouteStatus := ROUTED;\n        CurrentRoute.last_routed_timestamp := '2025-09-08T00:00:00Z';\n        FallbackTimerActive := FALSE;\n        unreadableLatch := FALSE;\n        fallbackTimer(IN := FALSE);\n        // clear any previously raised alarm\n        AlarmOut.Alarm_ID := '';\n        AlarmOut.Active := FALSE;\n        EXIT;\n      END_IF;\n      idx := idx + 1;\n    END_WHILE;\n    IF RouteStatus <> ROUTED THEN\n      // route code not recognized -> fallback behaviour\n      RouteCmd := 'HOLD_LANE_01';\n      CurrentRoute.route_code := Barcode_RouteCode;\n      CurrentRoute.destination := 'HOLD_LANE_01';\n      CurrentRoute.status := HOLD;\n      fallbackTimer(IN := TRUE, PT := T_FALLBACK);\n      FallbackTimerActive := TRUE;\n      unreadableLatch := TRUE;\n      // raise noncritical alarm record for SCADA/AlarmMgr\n      AlarmOut.Alarm_ID := CONCAT('MERGE_FBK_', Barcode_RouteCode);\n      AlarmOut.Severity := AlarmSeverity.MINOR;\n      AlarmOut.Active := TRUE;\n      AlarmOut.FirstOut := FALSE;\n      AlarmOut.Timestamp := '2025-09-08T00:00:00Z';\n      AlarmOut.Latched := FALSE;\n      AlarmOut.RequiresAck := FALSE;\n      RouteStatus := HOLD;\n    END_IF;\n  ELSE\n    // unreadable barcode: if first occurrence, latch unreadable and route to hold\n    IF NOT unreadableLatch THEN\n      RouteCmd := 'HOLD_LANE_01';\n      CurrentRoute.route_code := 'HOLD';\n      CurrentRoute.destination := 'HOLD_LANE_01';\n      CurrentRoute.status := HOLD;\n      fallbackTimer(IN := TRUE, PT := T_FALLBACK);\n      FallbackTimerActive := TRUE;\n      unreadableLatch := TRUE;\n      RouteStatus := HOLD;\n      // raise noncritical alarm\n      AlarmOut.Alarm_ID := 'MERGE_BARCODE_UNREADABLE';\n      AlarmOut.Severity := AlarmSeverity.MINOR;\n      AlarmOut.Active := TRUE;\n      AlarmOut.FirstOut := FALSE;\n      AlarmOut.Timestamp := '2025-09-08T00:00:00Z';\n      AlarmOut.Latched := FALSE;\n      AlarmOut.RequiresAck := FALSE;\n    ELSE\n      IF fallbackTimer.Q THEN\n        FallbackTimerActive := FALSE;\n        CurrentRoute.status := UNAVAILABLE;\n        RouteStatus := ERROR;\n        AlarmOut.Alarm_ID := 'MERGE_FALLBACK_TIMEOUT';\n        AlarmOut.Severity := AlarmSeverity.MAJOR;\n        AlarmOut.Active := TRUE;\n        AlarmOut.Timestamp := '2025-09-08T00:00:00Z';\n        AlarmOut.Latched := TRUE;\n        AlarmOut.RequiresAck := TRUE;\n      END_IF;\n    END_IF;\n  END_IF;\nEND_FUNCTION_BLOCK\n\n(* ---------- FB: FB_PalletizerHS ---------- *)\nFUNCTION_BLOCK FB_PalletizerHS\nVAR_INPUT\n  Pallet_Req_DI : BOOL;\n  Pallet_Ready_DI : BOOL;\n  Transfer_Complete_DI : BOOL;\n  ESTOP_ACTIVE : BOOL;\nEND_VAR\nVAR_OUTPUT\n  HandshakeState : (IDLE, REQUEST_TO_PLACE, ACK_PLACE_REQUEST, PALLET_READY, TRANSFER_IN_PROGRESS, TRANSFER_COMPLETE, FAULT, TIMEOUT);\n  LastError : STRING[64];\n  HS_Status : Pallet_Handshake_DDT;\n  Pallet_Ack_DO : BOOL;\n  Transfer_Start_DO : BOOL;\nEND_VAR\nVAR\n  requestAckTimer : TON;\n  transferTimer : TON;\n  ackRetryCount : INT;\n  transferRetryCount : INT;\n  initialization : BOOL;\nEND_VAR\n\nMETHOD PUBLIC Init : VOID\n  HandshakeState := IDLE;\n  LastError := '';\n  HS_Status.state := IDLE;\n  HS_Status.request_timestamp := '2025-09-08T00:00:00Z';\n  HS_Status.retry_count := 0;\n  HS_Status.last_error := '';\n  requestAckTimer(IN := FALSE);\n  transferTimer(IN := FALSE);\n  ackRetryCount := 0;\n  transferRetryCount := 0;\n  initialization := TRUE;\n  Pallet_Ack_DO := FALSE;\n  Transfer_Start_DO := FALSE;\nEND_METHOD\n\nBEGIN\n  IF initialization THEN\n    initialization := FALSE;\n  END_IF;\n\n  IF ESTOP_ACTIVE THEN\n    HandshakeState := FAULT;\n    LastError := 'ESTOP_ACTIVE';\n    Pallet_Ack_DO := FALSE;\n    Transfer_Start_DO := FALSE;\n    HS_Status.state := FAULT;\n    HS_Status.last_error := LastError;\n    RETURN;\n  END_IF;\n\n  CASE HandshakeState OF\n    IDLE:\n      Pallet_Ack_DO := FALSE;\n      Transfer_Start_DO := FALSE;\n      IF Pallet_Req_DI THEN\n        HandshakeState := REQUEST_TO_PLACE;\n        HS_Status.request_timestamp := '2025-09-08T00:00:00Z';\n        HS_Status.retry_count := 0;\n        requestAckTimer(IN := TRUE, PT := T_PALLET_ACK);\n      END_IF;\n\n    REQUEST_TO_PLACE:\n      Pallet_Ack_DO := TRUE;\n      IF Pallet_Ready_DI THEN\n        HandshakeState := ACK_PLACE_REQUEST;\n        requestAckTimer(IN := FALSE);\n        ackRetryCount := 0;\n      ELSIF requestAckTimer.Q THEN\n        requestAckTimer(IN := FALSE);\n        ackRetryCount := ackRetryCount + 1;\n        HS_Status.retry_count := ackRetryCount;\n        IF ackRetryCount <= PALLET_ACK_RETRIES THEN\n          requestAckTimer(IN := TRUE, PT := T_PALLET_RETRY_BACKOFF);\n        ELSE\n          HandshakeState := FAULT;\n          HS_Status.last_error := 'NoACK';\n          LastError := 'PalletizerNoACK';\n          Pallet_Ack_DO := FALSE;\n        END_IF;\n      END_IF;\n\n    ACK_PLACE_REQUEST:\n      Pallet_Ack_DO := TRUE;\n      IF Pallet_Ready_DI THEN\n        HandshakeState := PALLET_READY;\n      END_IF;\n\n    PALLET_READY:\n      Transfer_Start_DO := TRUE;\n      HandshakeState := TRANSFER_IN_PROGRESS;\n      transferTimer(IN := TRUE, PT := T_PALLET_TRANSFER);\n\n    TRANSFER_IN_PROGRESS:\n      Transfer_Start_DO := TRUE;\n      IF Transfer_Complete_DI THEN\n        transferTimer(IN := FALSE);\n        Transfer_Start_DO := FALSE;\n        HandshakeState := TRANSFER_COMPLETE;\n      ELSIF transferTimer.Q THEN\n        transferTimer(IN := FALSE);\n        transferRetryCount := transferRetryCount + 1;\n        IF transferRetryCount <= PALLET_TRANSFER_RETRIES THEN\n          HandshakeState := PALLET_READY;\n          transferTimer(IN := TRUE, PT := T_PALLET_TRANSFER);\n        ELSE\n          HandshakeState := FAULT;\n          HS_Status.last_error := 'TransferTimeout';\n          LastError := 'TransferTimeout';\n          Transfer_Start_DO := FALSE;\n        END_IF;\n      END_IF;\n\n    TRANSFER_COMPLETE:\n      HandshakeState := IDLE;\n      HS_Status.retry_count := 0;\n      HS_Status.last_error := '';\n      Pallet_Ack_DO := FALSE;\n      Transfer_Start_DO := FALSE;\n\n    FAULT:\n      Pallet_Ack_DO := FALSE;\n      Transfer_Start_DO := FALSE;\n\n    TIMEOUT:\n      HandshakeState := FAULT;\n\n  ELSE\n    HandshakeState := FAULT;\n    Pallet_Ack_DO := FALSE;\n    Transfer_Start_DO := FALSE;\n  END_CASE;\n\n  HS_Status.state := (CASE HandshakeState\n                      IDLE: IDLE;\n                      REQUEST_TO_PLACE: REQUEST;\n                      ACK_PLACE_REQUEST: ACK;\n                      PALLET_READY: READY;\n                      TRANSFER_IN_PROGRESS: TRANSFER;\n                      TRANSFER_COMPLETE: COMPLETE;\n                      FAULT: FAULT;\n                      ELSE FAULT END_CASE);\n  HS_Status.retry_count := (CASE HandshakeState\n                             REQUEST_TO_PLACE: HS_Status.retry_count;\n                             ELSE HS_Status.retry_count END_CASE);\n  HS_Status.last_error := LastError;\nEND_FUNCTION_BLOCK\n\n(* ---------- FC: docs/Scada_Tag_Map.md (generates Markdown mapping for reference) ---------- *)\nFUNCTION FC_Scada_Tag_Map : VOID\nVAR_OUTPUT\n  DocText : STRING[4000];\nEND_VAR\nVAR\n  s : STRING[4000];\nEND_VAR\n\nBEGIN\n  s := '';\n  s := CONCAT(s, '# SCADA Tag Map\\n\\n');\n  s := CONCAT(s, '**Purpose**: Map SCADA-facing tags to PLC data-block tags and datatypes (STRING/BOOL/ENUM/ARRAY) for OPC/Modbus integration.\\n\\n');\n  s := CONCAT(s, '## Public Interfaces\\n\\n');\n  s := CONCAT(s, '- PLC_Heartbeat -> DB_Diagnostics.PLC_Heartbeat_Monitored (BOOL)\\n');\n  s := CONCAT(s, '- PLC_Application_Version -> DB_Diagnostics.DiagnosticsOut.Application_Version (STRING)\\n');\n  s := CONCAT(s, '- PLC_Library_Version -> DB_Diagnostics.DiagnosticsOut.Library_Version (STRING)\\n');\n  s := CONCAT(s, '- CPU_Redundancy_Status -> DB_Diagnostics.DiagnosticsOut.CPU_Redundancy_Status (STRING)\\n');\n  s := CONCAT(s, '- HotStandby_Link_Status -> DB_Diagnostics.DiagnosticsOut.HotStandby_Link_Status (BOOL)\\n');\n  s := CONCAT(s, '- HotStandby_Link_LastChange_Timestamp -> DB_Diagnostics.HotStandby_Link_LastChange_Timestamp (STRING)\\n');\n  s := CONCAT(s, '- Remote_Rack_Status[] -> DB_Diagnostics.DiagnosticsOut.Remote_Rack_Status[] (ARRAY[WORD])\\n');\n  s := CONCAT(s, '- IO_Module_Status[] -> DB_Diagnostics.DiagnosticsOut.IO_Module_Status[] (ARRAY[WORD])\\n');\n  s := CONCAT(s, '- Alarm_List[] -> DB_AlarmMgr.ActiveAlarms[] (ARRAY of UDT_Alarm)\\n');\n  s := CONCAT(s, '- FirstOutAlarm -> DB_AlarmMgr.FirstOutAlarm (UDT_Alarm)\\n');\n  s := CONCAT(s, '- Conveyor1_MotorCmd -> DB_Conveyor1.MotorCmd (BOOL)\\n');\n  s := CONCAT(s, '- Conveyor1_JamState -> DB_Conveyor1.JamState (ENUM: NO_JAM/SOFT_JAM/HARD_JAM)\\n');\n  s := CONCAT(s, '- Merge1_RouteCmd -> DB_MergeDivert1.RouteCmd (STRING)\\n');\n  s := CONCAT(s, '- Merge1_FallbackTimerActive -> DB_MergeDivert1.FallbackTimerActive (BOOL)\\n');\n  s := CONCAT(s, '- PalletizerHS1_State -> DB_PalletizerHS1.HandshakeState (ENUM)\\n');\n  s := CONCAT(s, '- PalletizerHS1_LastError -> DB_PalletizerHS1.LastError (STRING)\\n');\n  s := CONCAT(s, '- BMENOC0321_Status -> DB_Comms.BMENOC0321_Status (STRING)\\n');\n  s := CONCAT(s, '- SCADA_Heartbeat_Ack -> DB_Comms.SCADA_Heartbeat_Ack (BOOL)\\n');\n  s := CONCAT(s, '\\n-- End of generated SCADA Tag Map --\\n');\n  DocText := s;\nEND_FUNCTION\n\n(* ---------- ORGANIZATION BLOCK: OB100 (Cold-start initialization) ---------- *)\nORGANIZATION_BLOCK OB100\nVAR\n  diagFB : FB_Diag;            // DB_Diagnostics\n  commsFB : FB_Comms;          // DB_Comms\n  alarmFB : FB_AlarmMgr;       // DB_AlarmMgr\n  convFB : FB_Conveyor;        // DB_Conveyor1\n  mergeFB : FB_MergeDivert;    // DB_MergeDivert1\n  palletFB : FB_PalletizerHS;  // DB_PalletizerHS1\n  modeMgr : FB_ModeMgr;        // DB_ModeMgr\n  scadaDoc : FC_Scada_Tag_Map; // document generator (non-critical)\n  // Seeded retentive defaults and warm-up signals\n  initialESTOP : BOOL := FALSE;\nEND_VAR\n\nBEGIN\n  // Initialize diagnostics, communications and alarm manager\n  diagFB.Init();\n  commsFB.Init();\n  alarmFB.Clear();\n\n  // Initialize control FBs\n  convFB.Init();\n  mergeFB.Init();\n  palletFB.Init();\n\n  // Initialize Mode Manager and seed retentive mode and permissions\n  modeMgr.Init();\n\n  // Comms warm-up: allow comms FB to establish baseline status before normal operation\n  // (commsFB.Init already executed); for redundancy the HSBY timestamp is seeded here\n  diagFB.DiagnosticsOut.Application_Version := '1.0.0 (build 2025-09-08)';\n  diagFB.DiagnosticsOut.Library_Version := 'LIB.1.0.0';\n\n  // Ensure safe outputs if ESTOP asserted at cold-start\n  IF initialESTOP THEN\n    // Force safe states across managers\n    convFB.ESTOP_ACTIVE := TRUE;\n    mergeFB.ESTOP_ACTIVE := TRUE;\n    palletFB.ESTOP_ACTIVE := TRUE;\n    // Set Mode Manager ESTOP input to ensure consistent state\n    modeMgr.ESTOP_In := TRUE;\n    modeMgr.CurrentMode := ESTOP;\n    modeMgr.ModeChangeTimestamp := '2025-09-08T00:00:00Z';\n  END_IF;\nEND_ORGANIZATION_BLOCK\n\n(* ---------- ORGANIZATION BLOCK: OB1 (Cyclic master) ---------- *)\nORGANIZATION_BLOCK OB1\nVAR\n  // Instances\n  DB_Diagnostics : FB_Diag;\n  DB_Comms : FB_Comms;\n  DB_AlarmMgr : FB_AlarmMgr;\n  DB_Conveyor1 : FB_Conveyor;\n  DB_MergeDivert1 : FB_MergeDivert;\n  DB_PalletizerHS1 : FB_PalletizerHS;\n  DB_ModeMgr : FB_ModeMgr;\n\n  // Public / I/O (example mapping; real mapping via DB I/O mapping)\n  PLC_Heartbeat : BOOL := FALSE;\n  SCADA_HB_In : BOOL := FALSE;\n  SCADA_HB_Ack_In : BOOL := FALSE;\n  Conveyor1_Sensor_Beam : BOOL := FALSE;\n  Conveyor1_Encoder_Moving : BOOL := TRUE;\n  Conveyor1_Cmd_Enable : BOOL := TRUE;\n  Merge1_Barcode_OK : BOOL := FALSE;\n  Merge1_Barcode_Code : STRING[16] := '';\n  Pallet_REQ_DI : BOOL := FALSE;\n  Pallet_READY_DI : BOOL := FALSE;\n  Transfer_COMPLETE_DI : BOOL := FALSE;\n  Global_ESTOP : BOOL := FALSE; // global estop input\n  ResetPermissivesCmd : BOOL := FALSE; // manual permissive reset for ESTOP recovery\n  Operator_Authorised_In : BOOL := FALSE;\n  Maintenance_Permit_In : BOOL := FALSE;\n  Simulation_Enabled_In : BOOL := FALSE;\n\n  scadaDoc : FC_Scada_Tag_Map;\n\n  // Mode command from SCADA/HMI (example)\n  ModeCmd_Request : (REQUEST_RUN_AUTO, REQUEST_RUN_MANUAL, REQUEST_STOP, REQUEST_MAINTENANCE, REQUEST_SIMULATION, REQUEST_ESTOPOFF) := REQUEST_RUN_MANUAL;\nEND_VAR\n\nBEGIN\n  // Toggle PLC heartbeat (in real system a timed task would toggle)\n  PLC_Heartbeat := NOT PLC_Heartbeat;\n\n  // Call Mode Manager first to determine allowed mode for the cycle\n  DB_ModeMgr(ModeCmd := ModeCmd_Request,\n             Perm_PLC_Health_OK := DB_Diagnostics.DiagnosticsOut.Application_Version <> '', // simplified health test\n             Perm_Power_Supplies_OK := TRUE,\n             Perm_HotStandby_Link_OK_or_StandbyReady := DB_Diagnostics.DiagnosticsOut.HotStandby_Link_Status,\n             Perm_No_High_Severity_SIF_Trip := TRUE,\n             Operator_Authorised := Operator_Authorised_In,\n             Maintenance_Permit := Maintenance_Permit_In,\n             Simulation_Enabled_Bit := Simulation_Enabled_In,\n             ResetPermissives := ResetPermissivesCmd,\n             ESTOP_In := Global_ESTOP);\n\n  // Diagnostics - supply heartbeat to diagnostics FB\n  DB_Diagnostics(PLC_Heartbeat_In := PLC_Heartbeat);\n\n  // Comms\n  DB_Comms(SCADA_Heartbeat_In := SCADA_HB_In, SCADA_Heartbeat_Ack_In := SCADA_HB_Ack_In);\n\n  // Alarm manager - pass through alarms produced by other FBs (MergeDivert example included)\n  DB_AlarmMgr(AlarmIn := DB_MergeDivert1.AlarmOut,\n              AcknowledgeID := '',\n              InhibitRequestID := '',\n              TriggerClear := FALSE);\n\n  // Conveyors and material handling (called after ModeMgr and AlarmMgr)\n  // Map global ESTOP into conveyor FBs\n  DB_Conveyor1(Sensor_Beam := Conveyor1_Sensor_Beam,\n               Encoder_Moving := Conveyor1_Encoder_Moving,\n               Cmd_Enable := (DB_ModeMgr.CurrentMode = RUN_AUTO OR DB_ModeMgr.CurrentMode = RUN_MANUAL) AND Conveyor1_Cmd_Enable,\n               ESTOP_ACTIVE := Global_ESTOP,\n               Interlocks_OK := TRUE);\n\n  // Merge/Divert\n  DB_MergeDivert1(Barcode_Read_OK := Merge1_Barcode_OK,\n                  Barcode_RouteCode := Merge1_Barcode_Code,\n                  FallbackPermissive := TRUE,\n                  ESTOP_ACTIVE := Global_ESTOP);\n\n  // Palletizer handshake\n  DB_PalletizerHS1(Pallet_Req_DI := Pallet_REQ_DI,\n                   Pallet_Ready_DI := Pallet_READY_DI,\n                   Transfer_Complete_DI := Transfer_COMPLETE_DI,\n                   ESTOP_ACTIVE := Global_ESTOP);\n\n  // Generate SCADA Tag Map documentation (non-critical path)\n  scadaDoc();\n\n  // Expose summary diagnostics to SCADA via DB_Diagnostics instance variables\n  // Example: DB_Diagnostics.DiagnosticsOut.Application_Version is populated by OB100 or FB_Diag\nEND_ORGANIZATION_BLOCK\n\n(* End of file *)\n"
    }
  ]
}