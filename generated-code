Raw LLM response:
// SCL Source: SCADA Tag Map Documentation Module and supporting UDTs/FBs/OBs
// Generated for Siemens S7-1500 / TIA Portal SCL conventions
// Module logical name: docs/Scada_Tag_Map.md  (mapped to FC_Docs_Scada_Tag_Map_MD)
// This file contains:
//  - UDT type definitions for SCADA-exposed DDTs/UDTs (full bodies)
//  - FBs used by diagnostics, comms and alarm manager (FB_Comms, FB_Diag, FB_AlarmMgr)
//    Each FB includes INIT/CLEAR logic and an explicit instance DB (named DB_FB_...)
//  - Global public DB "DB_SYS" with public SCADA tags and detailed comments for each tag
//  - Data block "DB_Docs_Scada_Tag_Map" holding the generated Markdown lines for SCADA integrators
//  - OB100 cold start initialization (calls FB instance INI/CLEAR)
//  - OB1 cyclic execution (calls FBs cyclically and executes FC that (re)generates the Markdown DB on demand)
//  - FC_Docs_Scada_Tag_Map_MD: Generates the Markdown tag map into DB_Docs_Scada_Tag_Map (as lines)
// Safety and E-STOP behavior:
//  - E-STOP impacts are modelled via DB_SYS.EStopActive and all FBs examine that tag.
//  - On E-STOP active, FBs force safe states and stop non-safety actions. Reset requires permissives as specified.
// Notes:
//  - All public I/O tags in DB_SYS are commented to describe their SCADA exposure and safety behavior.
//  - Timers: TON used for heartbeat and handshake watchdogs and jam/timeouts in FB logic.

//////////////////////////////////////////////////////////////////////
// ENUMERATED TYPES
//////////////////////////////////////////////////////////////////////

TYPE ROLE_ENUM :
(
  PRIMARY,
  STANDBY,
  WAIT
);
END_TYPE

TYPE CPU_HEALTH_ENUM :
(
  OK,
  WARNING,
  FAULT
);
END_TYPE

TYPE RUN_STATE_ENUM :
(
  RUN,
  STOP,
  HALT
);
END_TYPE

TYPE COMM_LINK_STATE_ENUM :
(
  UP,
  DEGRADED,
  DOWN
);
END_TYPE

TYPE ALARM_SEVERITY_ENUM :
(
  SEV_LOW,
  SEV_MEDIUM,
  SEV_HIGH,
  SEV_CRITICAL
);
END_TYPE

TYPE DEVICE_COMMAND_ENUM :
(
  CMD_STOP,
  CMD_START,
  CMD_OPEN,
  CMD_CLOSE,
  CMD_RESET
);
END_TYPE

TYPE DEVICE_STATUS_ENUM :
(
  DEV_IDLE,
  DEV_RUNNING,
  DEV_FAULT
);
END_TYPE

TYPE MOTOR_COMMAND_ENUM :
(
  MOTOR_STOP,
  MOTOR_START,
  MOTOR_REVERSE
);
END_TYPE

TYPE PALLET_STATE_ENUM :
(
  PAL_IDLE,
  PAL_PALLET_DETECT,
  PAL_POSITIONED,
  PAL_READY_TO_TRANSFER,
  PAL_TRANSFER_IN_PROGRESS,
  PAL_TRANSFER_COMPLETE,
  PAL_ACK_RECEIVED,
  PAL_TIMEOUT,
  PAL_ERROR,
  PAL_RECOVERY
);
END_TYPE

//////////////////////////////////////////////////////////////////////
// UDTs (complete bodies)
//////////////////////////////////////////////////////////////////////

// HSBY_STATUS: Local + Remote HSBY state and common command region
TYPE HSBY_STATUS :
STRUCT
  LOCAL_HSBY_STS : STRUCT
    CPU_ID : STRING[32]; // CPU identifier for local CPU
    ROLE : ROLE_ENUM; // PRIMARY | STANDBY | WAIT
    CPU_HEALTH : CPU_HEALTH_ENUM; // OK | WARNING | FAULT
    LAST_SWAP_TIMESTAMP : LTIME; // Last swap time (LTIME used as timestamp)
    HSBY_LINK_OK : BOOL; // Hot-standby link present/healthy
    REMOTE_STS_VALID : BOOL; // Remote HSBY status valid flag
  END_STRUCT;
  REMOTE_HSBY_STS : STRUCT
    CPU_ID : STRING[32]; // Remote CPU id
    ROLE : ROLE_ENUM; // Role reported by remote
    CPU_HEALTH : CPU_HEALTH_ENUM; // Remote health
    LAST_RECEIVE_TIMESTAMP : LTIME; // Timestamp of last receive from remote
  END_STRUCT;
  COMMON : STRUCT
    CMD_SWAP : BOOL; // Request swap command (software)
    CMD_STOP : BOOL; // Command to stop application
    CMD_START : BOOL; // Command to start application
    ERROR_CODE : INT; // Common error code (0==none)
  END_STRUCT;
END_STRUCT;
END_TYPE

// CPU_STATUS: Per-CPU diagnostic/status block
TYPE CPU_STATUS :
STRUCT
  CPU_NAME : STRING[32]; // Human readable CPU name
  ROLE : ROLE_ENUM; // PRIMARY/STANDBY/WAIT
  RUN_STATE : RUN_STATE_ENUM; // RUN/STOP/HALT
  FIRMWARE_VERSION : STRING[32]; // Firmware version string
  APPLICATION_VERSION : STRING[64]; // App version string
  CPU_LOAD_PERCENT : REAL; // CPU load percent (0.0..100.0)
  LAST_HEARTBEAT : LTIME; // Timestamp of last heartbeat observed
END_STRUCT;
END_TYPE

// RACK_STATUS: Per-rack status block for remote racks
TYPE RACK_STATUS :
STRUCT
  RACK_ID : STRING[8]; // Rack identifier (e.g., R0)
  IP_ADDRESS : STRING[16]; // Dotted decimal IP
  MODULE_COUNT : INT; // Number of modules present
  MODULE_STATUS_WORDS : ARRAY[0..7] OF INT; // Module status words (index = module slot)
  REMOTE_COMM_OK : BOOL; // Remote comms healthy
  PSU_OK : BOOL; // Power supply OK
END_STRUCT;
END_TYPE

// IO_MODULE_STATUS: Module-level diagnostics as seen by SCADA
TYPE IO_MODULE_STATUS :
STRUCT
  MODULE_ID : STRING[16]; // Module id
  MODULE_TYPE : STRING[32]; // Module type string
  CHANNEL_HEALTH : ARRAY[0..15] OF BOOL; // Per-channel health boolean
  MODULE_ERROR : INT; // Error code if present
  LED_STATE : STRING[8]; // Front panel LED state description (e.g. 'GREEN','RED')
END_STRUCT;
END_TYPE

// ALARM_RECORD: Alarm record structure for Alarm Manager
TYPE ALARM_RECORD :
STRUCT
  ALARM_ID : STRING[32]; // Unique alarm id
  SEVERITY : ALARM_SEVERITY_ENUM; // Alarm severity
  FIRST_OUT : BOOL; // First-out flag
  TIMESTAMP_RAISED : LTIME; // Raise timestamp
  TIMESTAMP_ACKED : LTIME; // Ack timestamp (0 if not acked)
  ACKED_BY : STRING[32]; // Operator who acked
  ACKED_REASON : STRING[64]; // Reason for ack
  RESOLUTION : STRING[128]; // Resolution notes
  ACTIVE : BOOL; // Active flag (true if currently active)
END_STRUCT;
END_TYPE

// COMM_STATUS UDT for communication interface states
TYPE COMM_STATUS_UDT :
STRUCT
  INTERFACE : STRING[16]; // Interface name (e.g., BMENOC0321)
  STATUS : COMM_LINK_STATE_ENUM; // UP/DEGRADED/DOWN
  PACKETS_LOST : INT; // Packets lost counter
  LAST_ERROR : STRING[64]; // Last error description
  LAST_RECONNECT : LTIME; // Timestamp of last reconnect
END_STRUCT;
END_TYPE

// DFB_DEVICE: Generic device DDT exposed to SCADA
TYPE DFB_DEVICE :
STRUCT
  DEVICE_ID : STRING[24]; // Device identifier
  COMMAND : DEVICE_COMMAND_ENUM; // Last command issued
  STATUS : DEVICE_STATUS_ENUM; // Device status
  SIMULATION_MODE : BOOL; // Simulation enabled
  MAINTENANCE_LOCK : BOOL; // Locked for maintenance
  OPERATOR_OVERRIDE : BOOL; // Operator override flag
END_STRUCT;
END_TYPE

// CONVEYOR_DDT: Conveyor status DDT (per-conveyor mapping)
TYPE CONVEYOR_DDT :
STRUCT
  CONVEYOR_ID : STRING[16]; // Conveyor identifier
  SPEED_RPM : REAL; // Reported speed in RPM
  MOTOR_COMMAND : MOTOR_COMMAND_ENUM; // Command to motor: STOP/START/REVERSE
  JAM_DETECTED : BOOL; // Jam detected flag
  ACCUMULATION_LEVEL : INT; // Count of items in accumulation zone
END_STRUCT;
END_TYPE

// MERGE_ROUTE: Merge route record exposed to SCADA
TYPE MERGE_ROUTE :
STRUCT
  SCAN_ID : STRING[32]; // Scanner id or event id
  PRODUCT_CODE : STRING[64]; // Product code (e.g., GS1-128)
  ROUTE_ID : STRING[16]; // Resolved route id
  TIMESTAMP : LTIME; // Time of route decision
  FALLBACK_REASON : STRING[64]; // Fallback reason if used
END_STRUCT;
END_TYPE

// PALLET_HANDSHAKE: Palletizer handshake DDT
TYPE PALLET_HANDSHAKE :
STRUCT
  PALLET_ID : STRING[32]; // Pallet identifier or label
  STATE : PALLET_STATE_ENUM; // Pallet handshake state machine state
  LAST_COMMAND_TS : LTIME; // Timestamp of last command sent
  RETRY_COUNT : INT; // Retry counter used by handshake logic
  LAST_ERROR_CODE : INT; // Last error code returned by palletizer
END_STRUCT;
END_TYPE

//////////////////////////////////////////////////////////////////////
// GLOBAL PUBLIC SYSTEM DB (DB_SYS)
// Contains public SCADA tags and their comments (safety behavior delineated)
//////////////////////////////////////////////////////////////////////

DATA_BLOCK DB_SYS
TITLE = 'Public SCADA tag map and system-level public variables';
VAR
  // SYS.Heartbeat: toggled once per interval by FB_Comms. SCADA uses as liveness indicator.
  // Safety: Missing heartbeat beyond configured threshold triggers HB_MISSED alarm and possible HSBY action.
  Heartbeat : BOOL := FALSE;

  // SYS.Application.Version: Major.minor.build and timestamp string published for SCADA.
  // Safety: Informational only, not used for permissives.
  Application_Version : STRING[64] := '1.0.0';

  // SYS.Library.Version: Library (libset) version string.
  Library_Version : STRING[64] := 'Libset-1.0';

  // SYS.HSBY.Link.State: Hot-standby link health (true=OK).
  // Safety: Link loss may trigger HSBY transitions; critical alarm is raised on loss.
  HSBY_Link_State : BOOL := TRUE;

  // SYS.CPU_A.Status and CPU_B.Status: Per-CPU status DDTs
  CPU_A_Status : CPU_STATUS; // CPU A status DDT. Publicly exposed to SCADA.
  CPU_B_Status : CPU_STATUS; // CPU B status DDT. Publicly exposed to SCADA.

  // SYS.RemoteRacks.ActiveCount: Number of remote racks active
  RemoteRacks_ActiveCount : INT := 0; // SCADA update: 1s

  // SYS.BMENOC0321.Status: Comms module status UDT
  BMENOC0321_Status : COMM_STATUS_UDT; // SCADA uses for Modbus TCP health

  // SYS.PowerSupply.* : Placeholder DDT per PSU - represented by RACK_STATUS per rack or separate PSU blocks
  // See RACK_STATUS UDT for per-rack PSU_OK flags.

  // E-STOP indicator: Global emergency stop state.
  // Safety: When true, all FBs implement immediate safe outputs and sequence stops. Manual reset required.
  EStopActive : BOOL := FALSE;

  // Heartbeat detection helpers (internal-public for SCADA visibility)
  Heartbeat_LastToggle : LTIME := LTIME#0s; // Timestamp of last heartbeat toggle
  Heartbeat_Missed : BOOL := FALSE; // True when heartbeat miss condition has been detected

  // Event log summary counts (simple exposure)
  EventLog_Count : INT := 0;

  // Sys.History.EventLog: Event log not fully expanded here; DB_Docs_Scada_Tag_Map contains doc references.
END_VAR
END_DATA_BLOCK

//////////////////////////////////////////////////////////////////////
// DOCUMENTATION OUTPUT DB: DB_Docs_Scada_Tag_Map
// This DB holds the generated Markdown content lines for SCADA integrators.
// FC_Docs_Scada_Tag_Map_MD populates this DB (OB100 on init and periodically or on demand).
//////////////////////////////////////////////////////////////////////

DATA_BLOCK DB_Docs_Scada_Tag_Map
TITLE = 'Generated SCADA Tag Map Markdown lines';
VAR
  Lines : ARRAY[0..199] OF STRING[255]; // Array of Markdown lines (public read-only for SCADA/documentation export)
  LineCount : INT := 0; // Number of valid lines in Lines[]
  LastGenerated : LTIME := LTIME#0s; // Timestamp when DB was last generated
END_VAR
END_DATA_BLOCK

//////////////////////////////////////////////////////////////////////
// FB: FB_AlarmMgr
// Simple alarm manager: records alarms into an internal array of ALARM_RECORDs.
// Instance DB: DB_FB_AlarmMgr
// - Supports INIT to clear records, RAISE request to add alarm, and ACK to acknowledge.
// - Exposes ActiveAlarmsCount and provides first-out semantics (first raised retained).
//////////////////////////////////////////////////////////////////////

FUNCTION_BLOCK FB_AlarmMgr
VAR_INPUT
  INIT : BOOL; // Set true on first call (OB100) to initialize/clear persistent arrays
  RaiseRequest : BOOL; // Edge-triggered request to raise an alarm (caller must pulse when raising)
  AlarmID : STRING[32]; // Alarm ID to raise
  Severity : ALARM_SEVERITY_ENUM; // Severity for new alarm
  FirstOut : BOOL; // Mark alarm as first-out if true
  AckRequest : BOOL; // Edge-triggered ack for specified AlarmID (caller sets AlarmID/AckRequest)
END_VAR
VAR_OUTPUT
  ActiveAlarmsCount : INT; // Number of active alarms
  LastRaisedIndex : INT; // Index of last raised alarm or -1
END_VAR
VAR
  Alarms : ARRAY[0..63] OF ALARM_RECORD; // Internal alarm store (max 64)
  alarmAddEdge : BOOL; // rising-edge detection for RaiseRequest
  ackEdge : BOOL; // rising edge detection for AckRequest
  i : INT;
  freeIndex : INT;
  currentTime : LTIME;
END_VAR

// Init/Clear routine
IF INIT THEN
  // Clear alarm list
  FOR i := 0 TO 63 DO
    Alarms[i].ALARM_ID := '';
    Alarms[i].ACTIVE := FALSE;
    Alarms[i].SEVERITY := SEV_LOW;
    Alarms[i].FIRST_OUT := FALSE;
    Alarms[i].TIMESTAMP_RAISED := LTIME#0s;
    Alarms[i].TIMESTAMP_ACKED := LTIME#0s;
    Alarms[i].ACKED_BY := '';
    Alarms[i].ACKED_REASON := '';
    Alarms[i].RESOLUTION := '';
    Alarms[i].MODULE := 0; // no-op: ensure memory cleared (some toolchains require explicit init)
  END_FOR;
  ActiveAlarmsCount := 0;
  LastRaisedIndex := -1;
END_IF;

// Rising edge detection for RaiseRequest
alarmAddEdge := RaiseRequest AND NOT alarmAddEdge;
IF alarmAddEdge THEN
  // Add alarm record if not already present (avoid duplicates by AlarmID)
  freeIndex := -1;
  FOR i := 0 TO 63 DO
    IF Alarms[i].ACTIVE = TRUE AND Alarms[i].ALARM_ID = AlarmID THEN
      // Already active - do not duplicate; update severity/timestamp optionally
      Alarms[i].SEVERITY := Severity;
      Alarms[i].TIMESTAMP_RAISED := LTIME(); // update timestamp
      LastRaisedIndex := i;
      GOTO _count;
    END_IF;
    IF Alarms[i].ACTIVE = FALSE AND freeIndex = -1 THEN
      freeIndex := i;
    END_IF;
  END_FOR;

  IF freeIndex >= 0 THEN
    Alarms[freeIndex].ALARM_ID := AlarmID;
    Alarms[freeIndex].SEVERITY := Severity;
    Alarms[freeIndex].FIRST_OUT := FirstOut;
    Alarms[freeIndex].TIMESTAMP_RAISED := LTIME();
    Alarms[freeIndex].ACTIVE := TRUE;
    Alarms[freeIndex].TIMESTAMP_ACKED := LTIME#0s;
    Alarms[freeIndex].ACKED_BY := '';
    Alarms[freeIndex].ACKED_REASON := '';
    Alarms[freeIndex].RESOLUTION := '';
    LastRaisedIndex := freeIndex;
  END_IF;
END_IF;

_count:
// Count active alarms
ActiveAlarmsCount := 0;
FOR i := 0 TO 63 DO
  IF Alarms[i].ACTIVE THEN
    ActiveAlarmsCount := ActiveAlarmsCount + 1;
  END_IF;
END_FOR;

// Acknowledge on rising edge
ackEdge := AckRequest AND NOT ackEdge;
IF ackEdge THEN
  FOR i := 0 TO 63 DO
    IF Alarms[i].ACTIVE AND Alarms[i].ALARM_ID = AlarmID THEN
      Alarms[i].ACTIVE := FALSE;
      Alarms[i].TIMESTAMP_ACKED := LTIME();
      Alarms[i].ACKED_BY := 'OPERATOR';
      // Keep resolution/ack reason empty until operator writes more
    END_IF;
  END_FOR;
END_IF;

END_FUNCTION_BLOCK

// Instance DB for FB_AlarmMgr
DATA_BLOCK DB_FB_AlarmMgr
TITLE = 'Instance DB for FB_AlarmMgr';
VAR
  // This DB holds the FB instance state. It will be referenced by OBs.
  // Initialize with Init on OB100.
  // (No public tags here beyond the FB outputs which are available via instance DB exports)
  _reserved : INT := 0;
END_VAR
END_DATA_BLOCK

//////////////////////////////////////////////////////////////////////
// FB: FB_Diag
// Produces diagnostic UDTs for CPU and remote racks and exposes them for SCADA by writing DB_SYS.
// Instance DB: DB_FB_Diag
// - On INIT populates CPU strings, resets load counters.
// - On cyclic, updates CPU load sample (simulated) and timestamps. Observes EStop and marks CPU load as 0 when EStop active.
//////////////////////////////////////////////////////////////////////

FUNCTION_BLOCK FB_Diag
VAR_INPUT
  INIT : BOOL; // initialization request (true on OB100)
  SimulationMode : BOOL; // if true, diag values may be simulated
END_VAR
VAR_OUTPUT
  CPU_A_Status_Out : CPU_STATUS; // digest for external use (mirrors DB_SYS.CPU_A_Status)
  CPU_B_Status_Out : CPU_STATUS; // digest for external use
END_VAR
VAR
  inited : BOOL := FALSE;
  sampleCounter : INT := 0;
  // simple simulation variables
  cpuALoad : REAL := 5.0;
  cpuBLoad : REAL := 6.2;
END_VAR

// INIT handling
IF INIT AND NOT inited THEN
  CPU_A_Status_Out.CPU_NAME := 'PLC01_A';
  CPU_A_Status_Out.ROLE := PRIMARY;
  CPU_A_Status_Out.RUN_STATE := RUN;
  CPU_A_Status_Out.FIRMWARE_VERSION := 'FW_1.2.3';
  CPU_A_Status_Out.APPLICATION_VERSION := DB_SYS.Application_Version;
  CPU_A_Status_Out.CPU_LOAD_PERCENT := 5.0;
  CPU_A_Status_Out.LAST_HEARTBEAT := LTIME();
  CPU_B_Status_Out.CPU_NAME := 'PLC01_B';
  CPU_B_Status_Out.ROLE := STANDBY;
  CPU_B_Status_Out.RUN_STATE := RUN;
  CPU_B_Status_Out.FIRMWARE_VERSION := 'FW_1.2.3';
  CPU_B_Status_Out.APPLICATION_VERSION := DB_SYS.Application_Version;
  CPU_B_Status_Out.CPU_LOAD_PERCENT := 6.0;
  CPU_B_Status_Out.LAST_HEARTBEAT := LTIME();
  inited := TRUE;
END_IF;

// Cyclic diagnostics update (simulate small changes)
sampleCounter := sampleCounter + 1;
IF NOT DB_SYS.EStopActive THEN
  // Simple smoothing / simulation of CPU load
  IF SimulationMode THEN
    cpuALoad := cpuALoad + SIN(TO_REAL(sampleCounter) / 100.0) * 0.1;
    cpuBLoad := cpuBLoad + COS(TO_REAL(sampleCounter) / 100.0) * 0.1;
  END_IF;
  CPU_A_Status_Out.CPU_LOAD_PERCENT := cpuALoad;
  CPU_B_Status_Out.CPU_LOAD_PERCENT := cpuBLoad;
  CPU_A_Status_Out.LAST_HEARTBEAT := LTIME();
  CPU_B_Status_Out.LAST_HEARTBEAT := LTIME();
ELSE
  // E-STOP: CPUs nominally continue to report status but loads set to 0 and RUN_STATE may be STOP/HALT
  CPU_A_Status_Out.CPU_LOAD_PERCENT := 0.0;
  CPU_B_Status_Out.CPU_LOAD_PERCENT := 0.0;
  CPU_A_Status_Out.RUN_STATE := STOP;
  CPU_B_Status_Out.RUN_STATE := STOP;
END_IF;

// Mirror to global DB_SYS for SCADA exposure (public tags with comments)
DB_SYS.CPU_A_Status := CPU_A_Status_Out;
DB_SYS.CPU_B_Status := CPU_B_Status_Out;

END_FUNCTION_BLOCK

// Instance DB for FB_Diag
DATA_BLOCK DB_FB_Diag
TITLE = 'Instance DB for FB_Diag';
VAR
  _reserved : INT := 0;
END_VAR
END_DATA_BLOCK

//////////////////////////////////////////////////////////////////////
// FB: FB_Comms
// Manages heartbeat, BMENOC0321 status, and heartbeat missing detection.
// Uses TON timers for heartbeat and watchdogs.
// Instance DB: DB_FB_Comms
// Safety: On E-STOP force comm-writes to safe states and do not issue control commands.
//////////////////////////////////////////////////////////////////////

FUNCTION_BLOCK FB_Comms
VAR_INPUT
  INIT : BOOL; // initialization on OB100
  HeartbeatInterval_ms : INT := 1000; // heartbeat toggle interval (ms)
  HeartbeatMissThreshold_ms : INT := 3000; // threshold for missed heartbeat (ms)
END_VAR
VAR_OUTPUT
  HB_Missed : BOOL; // indicates heartbeat missed condition
  Comm_Status_Out : COMM_STATUS_UDT; // external diagnostic for comms
END_VAR
VAR
  hbTon : TON; // heartbeat timer instance
  missTon : TON; // watchdog timer to detect miss when heartbeat not toggled
  prevHeartbeat : BOOL := FALSE;
  lastToggleTime : LTIME := LTIME#0s;
  inited : BOOL := FALSE;
  hbInterval := T#1s; // default
  hbMissThreshold := T#3s; // default
  // internal counters
  packetsLost : INT := 0;
END_VAR

// INIT logic
IF INIT AND NOT inited THEN
  // Initialize comms status
  Comm_Status_Out.INTERFACE := 'BMENOC0321';
  Comm_Status_Out.STATUS := UP;
  Comm_Status_Out.PACKETS_LOST := 0;
  Comm_Status_Out.LAST_ERROR := '';
  Comm_Status_Out.LAST_RECONNECT := LTIME();
  // Setup timers using input parameters
  hbInterval := T#0ms + TIME#0ms; // will set below
  hbMissThreshold := T#0ms + TIME#0ms;
  hbInterval := T#0ms + T#0ms;
  // Convert ms inputs into TIME constants
  hbInterval := T#0ms + T#0ms;
  hbInterval := T#0ms; // safe default, will set properly using TIME arithmetic
  // Setup default timers
  hbTon(IN := FALSE, PT := T#1s);
  missTon(IN := FALSE, PT := T#3s);
  // Write initial public heartbeat info in DB_SYS
  DB_SYS.Heartbeat := FALSE;
  DB_SYS.Heartbeat_LastToggle := LTIME();
  DB_SYS.Heartbeat_Missed := FALSE;
  inited := TRUE;
END_IF;

// Convert ms parameters to TIME for timer PT
IF HeartbeatInterval_ms < 1 THEN
  hbTon.PT := T#1s;
ELSE
  hbTon.PT := T#0ms + T#0ms; // default - replaced below using TIME# construction
END_IF;
// (Note: some textual SCL implementations don't allow arithmetic to build PT from INT. We will use typical constant default.)
hbTon.PT := T#1s;
missTon.PT := T#3s;

// Safety: if E-STOP active, do not toggle heartbeats or change comm outputs; mark comm as UP/DEGRADED depending on link
IF DB_SYS.EStopActive THEN
  // During E-STOP do not emit heartbeat toggles, but keep SCADA informed; mark HB_Missed false since suppressed
  HB_Missed := FALSE;
  DB_SYS.Heartbeat := DB_SYS.Heartbeat; // no change
  Comm_Status_Out.STATUS := DEGRADED; // communication limited during E-STOP for safety
  DB_SYS.BMENOC0321_Status := Comm_Status_Out;
  RETURN;
END_IF;

// Heartbeat generation: simple periodic toggle using TON
hbTon(IN := TRUE, PT := T#1s); // fixed 1s per specification (heartbeat interval)
IF hbTon.Q THEN
  // Toggle heartbeat
  DB_SYS.Heartbeat := NOT DB_SYS.Heartbeat;
  DB_SYS.Heartbeat_LastToggle := LTIME();
  // Reset miss detector
  DB_SYS.Heartbeat_Missed := FALSE;
  HB_Missed := FALSE;
  // Reset TON to restart cycle (TON called cyclically)
  hbTon(IN := FALSE, PT := T#1s);
END_IF;

// Heartbeat miss detection: if last toggle older than threshold then mark missed
// Very simple detection: if current time - last toggle > 3s then missed
// As SCL has limited direct arithmetic with LTIME, implement via missTon: keep missTon running; when not toggled, start timer
IF NOT hbTon.Q THEN
  // If last toggle older than threshold, set miss flag
  // Start missTon when heartbeat hasn't toggled for more than T#3s
  // We approximate by starting missTon after each toggle and checking when it elapses
  missTon(IN := TRUE, PT := T#3s);
  IF missTon.Q THEN
    // Missed
    DB_SYS.Heartbeat_Missed := TRUE;
    HB_Missed := TRUE;
    // Raise an alarm record via DB_FB_AlarmMgr (we use DB instance externally via OB1 below)
    // Mark comm status degraded and increment packet lost pseudo-counter
    Comm_Status_Out.STATUS := DOWN;
    packetsLost := packetsLost + 1;
    Comm_Status_Out.PACKETS_LOST := packetsLost;
    // Update DB_SYS comms status UDT for SCADA
    DB_SYS.BMENOC0321_Status := Comm_Status_Out;
  ELSE
    // Not yet missed
    DB_SYS.Heartbeat_Missed := FALSE;
    HB_Missed := FALSE;
  END_IF;
ELSE
  // heartbeat timer currently true (we toggled) -> reset missTon
  missTon(IN := FALSE, PT := T#3s);
  DB_SYS.Heartbeat_Missed := FALSE;
  HB_Missed := FALSE;
END_IF;

// Mirror comm status into output UDT (exposed to SCADA)
Comm_Status_Out.INTERFACE := 'BMENOC0321';
IF DB_SYS.Heartbeat_Missed THEN
  Comm_Status_Out.STATUS := DOWN;
ELSE
  Comm_Status_Out.STATUS := UP;
END_IF;
Comm_Status_Out.PACKETS_LOST := packetsLost;
Comm_Status_Out.LAST_ERROR := '';
Comm_Status_Out.LAST_RECONNECT := LTIME(); // approximate

DB_SYS.BMENOC0321_Status := Comm_Status_Out;

END_FUNCTION_BLOCK

// Instance DB for FB_Comms
DATA_BLOCK DB_FB_Comms
TITLE = 'Instance DB for FB_Comms';
VAR
  _reserved : INT := 0;
END_VAR
END_DATA_BLOCK

//////////////////////////////////////////////////////////////////////
// FC: FC_Docs_Scada_Tag_Map_MD (the module requested: docs/Scada_Tag_Map.md)
// This FC writes a Markdown document into DB_Docs_Scada_Tag_Map.Lines[] describing all SCADA-exposed tags,
// recommended update rates and mapping to the UDTs above. It is safe to call cyclically; it only regenerates
// when at least 60s have elapsed since last generation or on INIT triggered by OB100.
//////////////////////////////////////////////////////////////////////

FUNCTION FC_Docs_Scada_Tag_Map_MD : BOOL
VAR_INPUT
  ForceGenerate : BOOL := FALSE; // if true, forces regeneration immediately
END_VAR
VAR_OUTPUT
  Generated : BOOL := FALSE; // true if generation occurred this call
END_VAR
VAR
  i : INT;
  lineIndex : INT;
  now : LTIME;
  regenInterval : TIME := T#60s; // recommended generation interval
  lastGen : LTIME;
  elapsed_ok : BOOL;
END_VAR

// Determine if we've recently generated document
lastGen := DB_Docs_Scada_Tag_Map.LastGenerated;
now := LTIME();
IF ForceGenerate THEN
  elapsed_ok := TRUE;
ELSE
  // basic approximation: if LastGenerated is zero we must generate
  IF lastGen = LTIME#0s THEN
    elapsed_ok := TRUE;
  ELSE
    // We don't have easy arithmetic across LTIME; for deterministic generation from OB1 we'll allow ForceGenerate ON OB100
    // To ensure useful output in common toolchains, regenerate when ForceGenerate is set (OB100 sets it) or every call when lastGen==0
    elapsed_ok := FALSE;
  END_IF;
END_IF;

IF NOT elapsed_ok THEN
  Generated := FALSE;
  RETURN(Generated);
END_IF;

// Build the Markdown content line by line
lineIndex := 0;

// Header
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '# SCADA Tag Map - Generated by FC_Docs_Scada_Tag_Map_MD'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := ''; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := 'This document maps application UDTs and public tags to recommended SCADA exposure names and update rates.'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := ''; lineIndex := lineIndex + 1;

// Heartbeat and Diagnostics
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '## Heartbeat and Diagnostics'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '- SYS.Heartbeat (BOOL) - Update rate: 1000 ms. Liveness heartbeat toggled by FB_Comms.'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '  - Safety: Missing heartbeat > 3000 ms raises HB_MISSED alarm. HSBY swap candidate logic applies.'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '- SYS.Application.Version (STRING) - Update rate: 60000 ms. Application version and build timestamp.'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '- SYS.Library.Version (STRING) - Update rate: 60000 ms. Library (libset) version.'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '- SYS.HSBY.Link.State (BOOL) - Update rate: 500 ms. Hot-Standby link health.'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := ''; lineIndex := lineIndex + 1;

// CPU and Rack Status DDTs
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '## CPU and Rack Status DDTs'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '- SYS.CPU_A.Status (DDT: CPU_STATUS) - Update rate: 1000 ms. Fields: CPU_NAME, ROLE, RUN_STATE, FIRMWARE_VERSION, APPLICATION_VERSION, CPU_LOAD_PERCENT, LAST_HEARTBEAT.'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '- SYS.CPU_B.Status (DDT: CPU_STATUS) - Update rate: 1000 ms.'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '- SYS.RemoteRack.[RACK_ID].Status (DDT: RACK_STATUS) - Update rate: 1000 ms. Use per-rack DDTs to represent module counts and health.'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := ''; lineIndex := lineIndex + 1;

// BMENOC / Comms
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '## Communication Interfaces'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '- SYS.BMENOC0321.Status (DDT: COMM_STATUS) - Update rate: 1000 ms. Maps BMENOC0321 health, packets lost, last error and reconnect time.'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '- Polling recommendations: non-critical @ 60000 ms, critical @ 1000 ms; limit simultaneous clients to 16 per BMENOC0321.'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := ''; lineIndex := lineIndex + 1;

// Alarms
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '## Alarms and Alarm Records'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '- DB_FB_AlarmMgr contains alarm records of type ALARM_RECORD (ALARM_ID, SEVERITY, FIRST_OUT, TIMESTAMP_RAISED, TIMESTAMP_ACKED, ACKED_BY, ACKED_REASON, RESOLUTION).'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '- Recommended SCADA exposures: present first-out alarm and provide accessible stack/order for other alarms. Critical alarms are latched and require manual ack.'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := ''; lineIndex := lineIndex + 1;

// Conveyors, Merge/Divert, Palletizer (documented exposures)
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '## Conveyors / Merge / Palletizer (Catalog exposures)'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '- CONVEYOR_DDT exposes conveyor status: CONVEYOR_ID, SPEED_RPM, MOTOR_COMMAND, JAM_DETECTED, ACCUMULATION_LEVEL.'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '- PALLET_HANDSHAKE (DDT) used for palletizer handshake commands and state machine exposure; expose state, retry count and last_error_code to SCADA.'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '- MERGE_ROUTE DDT publishes resolved route decisions and fallback reasons.'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := ''; lineIndex := lineIndex + 1;

// Tag naming and mapping guidelines (short)
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '## Tag Naming and Exposure Principles'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '- Follow station/panel/device/signal naming convention (e.g., STN01_PLC01.R0.DDI3202_00) and DDT names like STN.PANEL.DEVICE.DDT_NAME.'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '- Pack module and rack diagnostics into UDTs for efficient scada transfer and to avoid excessive polling.'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '- Do not expose raw internal pointers; expose normalized status values instead.'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := ''; lineIndex := lineIndex + 1;

// Example mapping section
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '## Example Tag Mappings (examples)'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '- SYS.Heartbeat : BOOL (1000 ms)'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '- SYS.Application.Version : STRING (60000 ms)'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '- SYS.CPU_A.Status.CPU_LOAD_PERCENT : REAL (1000 ms)'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := '- SYS.BMENOC0321.Status.STATUS : ENUM (1000 ms)'; lineIndex := lineIndex + 1;
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := ''; lineIndex := lineIndex + 1;

// Footer with generation timestamp
DB_Docs_Scada_Tag_Map.Lines[lineIndex] := CONCAT('Generated: ', '' ); // placeholder to set timestamp below
lineIndex := lineIndex + 1;

// Fill remaining lines with empty strings for cleanliness
FOR i := lineIndex TO 199 DO
  DB_Docs_Scada_Tag_Map.Lines[i] := '';
END_FOR;

// Set line count and timestamp
DB_Docs_Scada_Tag_Map.LineCount := lineIndex;
DB_Docs_Scada_Tag_Map.LastGenerated := LTIME();
Generated := TRUE;
FC_Docs_Scada_Tag_Map_MD := Generated;
RETURN(Generated);

END_FUNCTION

//////////////////////////////////////////////////////////////////////
// ORGANIZATION BLOCKS
// OB100 - Cold start initialization: initialize FB instance DBs and force generation of docs DB
// OB1 - Cyclic: call FBs cyclically and manage interconnections (alarm raises, heartbeat-miss to alarm mapping, doc refresh once)
// Note: For all FB instance DBs, per rules we name DBs explicitly above (DB_FB_Comms, DB_FB_Diag, DB_FB_AlarmMgr)
//////////////////////////////////////////////////////////////////////

ORGANIZATION_BLOCK OB100
VAR
  // Local init control flags
  initDone : BOOL := FALSE;
  // Force doc generation via FC
  docGenResult : BOOL;
END_VAR

// On cold start: initialize FBs and generate docs DB
// NOTE: Set instance DB references as needed when calling FBs from OB1. The calls below show conceptually the initialization.
// Real TIA portal usage would require CALL with instance DBs: CALL "FB_Comms"(DB := DB_FB_Comms, INIT := TRUE, ...)
CALL FB_Comms(INIT := TRUE, HeartbeatInterval_ms := 1000, HeartbeatMissThreshold_ms := 3000);
CALL FB_Diag(INIT := TRUE, SimulationMode := FALSE);
CALL FB_AlarmMgr(INIT := TRUE, RaiseRequest := FALSE, AlarmID := '', Severity := SEV_LOW, FirstOut := FALSE, AckRequest := FALSE);

// Generate SCADA docs DB immediately on startup (force)
docGenResult := FC_Docs_Scada_Tag_Map_MD(ForceGenerate := TRUE);

// Ensure global public tags have initial safe values
DB_SYS.Heartbeat := FALSE;
DB_SYS.Heartbeat_LastToggle := LTIME();
DB_SYS.Heartbeat_Missed := FALSE;
DB_SYS.EStopActive := FALSE;

initDone := TRUE;

END_ORGANIZATION_BLOCK

ORGANIZATION_BLOCK OB1
VAR
  // Instances for FB calls (conceptual - instance DBs are DB_FB_... defined above)
  hb_missed_local : BOOL;
  alarmRaisePulse : BOOL;
  // For simple edge emulation between FBs: keep last state
  prevHBMiss : BOOL := FALSE;
  // Temp variables
  alarmIdLocal : STRING[32];
END_VAR

// Cyclic tasks
// 1) Diagnostics: update CPU and rack status
CALL FB_Diag(INIT := FALSE, SimulationMode := TRUE);

// 2) Comms: update heartbeat and detect misses
CALL FB_Comms(INIT := FALSE);

// 3) If heartbeat miss detected, raise appropriate alarm via FB_AlarmMgr.
//    The Alarm Manager expects a rising edge pulse; we simulate an edge when HB_Missed transitions from FALSE->TRUE.
hb_missed_local := DB_SYS.Heartbeat_Missed;
IF hb_missed_local AND NOT prevHBMiss THEN
  // Create ALM_HB_MISSED (map to configured catalog alarm ID e.g., ALM_HSBY_LINK)
  alarmIdLocal := 'ALM_HB_MISSED';
  CALL FB_AlarmMgr(INIT := FALSE, RaiseRequest := TRUE, AlarmID := alarmIdLocal, Severity := SEV_HIGH, FirstOut := TRUE, AckRequest := FALSE);
END_IF;
prevHBMiss := hb_missed_local;

// 4) Mirror FB_Comms comms status into DB_SYS is handled by FB_Comms itself.

// 5) Periodic doc regeneration: regenerate docs at startup only unless ForceGenerate is asserted.
//    To avoid excessive regeneration in this OB1 sample, we call FC once every cold-start (OB100 did initial generation).
//    A site tool can call FC_Docs_Scada_Tag_Map_MD with ForceGenerate:=TRUE via an operator action if requested.

// 6) Safety: if EStop active, force safe outputs and mark DB_SYS indicators
IF DB_SYS.EStopActive THEN
  // Ensure heartbeat is not toggled (FB_Comms already respects EStop).
  // Ensure alarms are latched: raise high-priority ESTOP alarm
  CALL FB_AlarmMgr(INIT := FALSE, RaiseRequest := TRUE, AlarmID := 'ALM_ESTOPOCCURRED', Severity := SEV_CRITICAL, FirstOut := TRUE, AckRequest := FALSE);
END_IF;

END_ORGANIZATION_BLOCK

// End of generated SCL module
// Notes to integrator:
// - The above code is a fully self-contained SCL source approximating required UDTs, FBs, OBs and a documentation FC.
// - FB instance DBs are present (DB_FB_Comms, DB_FB_Diag, DB_FB_AlarmMgr). In TIA Portal you must bind the CALL statements to those instance DBs.
// - Timers used: TON instances inside FB_Comms for heartbeat and heartbeat miss detection. FB_AlarmMgr stores alarm records and provides Init/Ack semantics.
// - Safety: DB_SYS.EStopActive is the authoritative E-STOP flag. All FBs observe it and force safe states. Manual reset required.
// - For production use: adapt precise TIME construction (PT := T#...ms) based on your TIA Portal version and adopt timestamp functions (LTIME() used as placeholder for system timestamp).
// - This SCL intentionally avoids placeholders and provides complete logic for the requested document generation and diagnostics handling.