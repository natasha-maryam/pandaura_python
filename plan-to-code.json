{
  "docs/Scada_Tag_Map.md": "// SCL source for Siemens TIA Portal (S7-1500 family)\n// Module: docs/Scada_Tag_Map.md\n// Purpose: Function (FC) that generates and stores the SCADA Tag Map Markdown content in a Data Block.\n// Also provides supporting UDTs, Function Blocks (FBs) and Organization Blocks (OB100/OB1).\n// - Uses TON/TOF timers for heartbeat, jam-detection and handshake watchdogs.\n// - Implements Mode Manager as CASE state machine with explicit timeouts.\n// - Alarm Manager implements latched alarms requiring ack/clear where configured.\n// - Comments on all public DB references and public fields are provided.\n// - E-Stop behaviour: when ESTOP asserted, ModeMgr forces safe outputs and requires reset permissives to return to RUN.\n//\n// Note: This SCL is written to TIA Portal SCL conventions. It includes UDT definitions, FB definitions,\n// DB instance declarations, OB100 (cold start init) and OB1 (cyclic). The main deliverable FC\n// (FC_Scada_Tag_Map) populates a DB with Markdown content for SCADA teams.\n\n\n// -----------------------------\n// UDT Definitions\n// -----------------------------\nTYPE T_M_ECPU_HSBY : STRUCT\n    // Hot Standby Derived Data Type exchanged periodically between CPUs\n    LOCAL_HSBY_STS : STRUCT\n        CPU_ROLE           : STRING[16];   // Primary|Standby|Wait|Halt\n        CPU_STATE          : STRING[16];   // RUN|STOP|HALT|WAIT|SIMULATION\n        CPU_UPTIME_S       : UDINT;        // Uptime seconds\n        CPU_TEMPERATURE_C  : REAL;         // CPU temp\n        MAIN_IP            : STRING[32];   // Main IP address string\n        BACKUP_IP          : STRING[32];   // Backup IP address\n        HSBY_LINK_HEALTH   : BOOL;         // HSBY link healthy flag\n        LAST_EXCHANGE_TS   : ULINT;        // Timestamp of last exchange (UTC ms)\n    END_STRUCT;\n    REMOTE_HSBY_STS : STRUCT\n        CPU_ROLE           : STRING[16];\n        CPU_STATE          : STRING[16];\n        REMOTE_STS_VALID   : BOOL;\n        LAST_RECEIVED_TS   : ULINT;\n    END_STRUCT;\n    COMMON : STRUCT\n        CMD_SWAP           : BOOL;         // Command to swap primary/standby\n        CMD_STOP           : BOOL;         // Command to stop\n        REMOTE_STS_VALID   : BOOL;\n        ERROR_CODE         : UINT;\n        LAST_SWAP_TS       : ULINT;\n    END_STRUCT;\nEND_STRUCT\nEND_TYPE\n\nTYPE PLC_CPU_Status : STRUCT\n    // Status object published to SCADA\n    AppVersion     : STRING[32];  // Application version string (Major.Minor.Build)\n    LibVersion     : STRING[32];  // Library set version\n    Role           : STRING[8];   // PRIMARY/STANDBY\n    State          : STRING[8];   // RUN/STOP/HALT\n    Uptime_s       : UDINT;       // Uptime in seconds\n    SDCardPresent  : BOOL;        // SD card present flag\n    MemoryUsageKB  : UDINT;       // Memory usage in KB\nEND_STRUCT\nEND_TYPE\n\nTYPE RIO_Module_Status : STRUCT\n    // Per-module packed status\n    ModuleID          : STRING[32]; // Module identifier string\n    StatusWord        : UINT;       // Packed module status word (LEDs/diag)\n    ChannelFaultBitmap: UDINT;      // Bitmap of channel faults\n    FrontPanelLEDWord : UINT;       // Front panel LED packed word\n    LastDiagTS        : ULINT;      // Last diagnostic timestamp (UTC ms)\nEND_STRUCT\nEND_TYPE\n\nTYPE AlarmDDT : STRUCT\n    // Standard alarm structure for SCADA\n    AlarmID      : STRING[32];  // Unique alarm identifier\n    Severity     : STRING[16];  // critical/noncritical/etc.\n    Timestamp    : ULINT;       // UTC ms timestamp of activation\n    Latched      : BOOL;        // Latched state\n    Acknowledged : BOOL;        // Acknowledged by operator\n    AckUser      : STRING[32];  // User who acknowledged\n    ClearUser    : STRING[32];  // User who cleared\n    Description  : STRING[128]; // Human readable description\nEND_STRUCT\nEND_TYPE\n\nTYPE DeviceControlDDT : STRUCT\n    // Generic device control block for valves/motors\n    CommandMode   : STRING[8];  // AUTO/MANUAL/REMOTE\n    StartCmd      : BOOL;       // Start command\n    StopCmd       : BOOL;       // Stop command\n    OpenCmd       : BOOL;       // Open command (valve)\n    CloseCmd      : BOOL;       // Close command (valve)\n    FeedbackState : STRING[16]; // Feedback textual state\n    Fault         : BOOL;       // Device fault\n    MaintenanceMode: BOOL;      // Maintenance mode flag\n    SimEnable     : BOOL;       // Simulation enabled for device\nEND_STRUCT\nEND_TYPE\n\nTYPE CommAddressDDT : STRUCT\n    // Address descriptor for Modbus/remote comms\n    Protocol        : STRING[16]; // ModbusTCP/ModbusRTU/EtherNetIP/Profibus\n    IPAddress       : STRING[32]; // IP address\n    Port            : UINT;       // Port number\n    UnitID          : USINT;      // Modbus Unit ID\n    RegisterAddress : UINT;       // Register address\n    RegisterCount   : UINT;       // Number of registers\n    Timeout_ms      : UDINT;      // Timeout for comms\nEND_STRUCT\nEND_TYPE\n\nTYPE EventLogEntry : STRUCT\n    // Timestamped event record\n    EventID       : STRING[32];\n    TimestampUTC  : ULINT;       // UTC ms\n    Source        : STRING[32];\n    Severity      : STRING[16];\n    Description   : STRING[128];\n    UserID        : STRING[32];\n    CorrelationID : STRING[32];\nEND_STRUCT\nEND_TYPE\n\n\n// -----------------------------\n// Function Block: FB_Comms\n// - Responsible for heartbeats used by SCADA and HSBY monitoring.\n// - Exposes heartbeat tags and raises ALM_CPU_FAULT on timeout.\n// -----------------------------\nFUNCTION_BLOCK FB_Comms\nVAR_INPUT\n    // ESTOP request from safety network. When true, comms reports safe and heartbeats suppressed.\n    EstopActive : BOOL; // Public: ESTOP input; when true, COMMS enters safe heartbeat suppression mode.\nEND_VAR\nVAR_OUTPUT\n    // CPU heartbeat tag (exposed to SCADA). Updated each cycle when not EstopActive.\n    CPU_Heartbeat_TS : ULINT; // Public: Timestamp (UTC ms) of last heartbeat update\n    // HSBY heartbeat tag for standby communication (short interval).\n    HSBY_HB_TS       : ULINT; // Public: Timestamp (UTC ms) of last HSBY heartbeat\n    // Fault flag indicating heartbeat loss (latched until reset).\n    Heartbeat_Fault  : BOOL;  // Public: When true, ALM_CPU_FAULT equivalent condition asserted.\nEND_VAR\nVAR\n    hbTimer    : TON;        // Timer used to detect CPU heartbeat timeout (PT configured in instance)\n    hsTimer    : TON;        // Timer for HSBY heartbeat timeout\n    lastTick   : ULINT;      // Internal last tick stored\n    initDone   : BOOL;       // Init complete flag\n    hbTimeout  : TIME := T#15s; // Heartbeat timeout default\n    hsTimeout  : TIME := T#3s;  // HSBY heartbeat timeout default\nEND_VAR\n// No methods; CLEAR/INIT controlled via OB100 and OB1 calls to Reset/Init routines implemented below.\n\nBEGIN\n    // If Estop is active we do not issue normal heartbeats and assert fault state for safety\n    IF NOT initDone THEN\n        // Initialize internal timers\n        hbTimer(IN := FALSE, PT := hbTimeout);\n        hsTimer(IN := FALSE, PT := hsTimeout);\n        Heartbeat_Fault := FALSE;\n        initDone := TRUE;\n    END_IF;\n\n    IF EstopActive THEN\n        // ESTOP behaviour: force safe outputs / not provide heartbeat\n        // Public comment: ESTOP forces safe outputs; heartbeats suppressed until ESTOP cleared and reset permissives satisfied.\n        CPU_Heartbeat_TS := CPU_Heartbeat_TS; // hold last value\n        HSBY_HB_TS := HSBY_HB_TS;             // hold last value\n        Heartbeat_Fault := TRUE;\n        // Keep timers stopped\n        hbTimer(IN := FALSE, PT := hbTimeout);\n        hsTimer(IN := FALSE, PT := hsTimeout);\n    ELSE\n        // Normal operation: update heartbeat timestamps and run timers\n        // Simulate heartbeat update on each call: use system tick via \"_TIME()\" like function not available,\n        // use SYSTIME via SCL function TIME() not available in pure SCL; we rely on built-in \"TO_UTC\" substitutes.\n        // Use CURRENT_TIME system function by reading \"TIME#0ms + SysTime\"? For portability, use TIMESTAMP via function \"DTL_TO_UDINT\" not available.\n        // To keep deterministic, use internal increment tick by TON rising edges: when hbTimer.Q becomes true -> set fault.\n        // Update timers - start them to detect timeouts\n        hbTimer(IN := TRUE, PT := hbTimeout);\n        hsTimer(IN := TRUE, PT := hsTimeout);\n\n        // Update heartbeat timestamps each scan - use S5TIME-derived tick (coarse) but represent as UDINT of system tick\n        CPU_Heartbeat_TS := CPU_Heartbeat_TS + 1000; // increment by 1s per scan approximation (documented as simulated time)\n        HSBY_HB_TS := HSBY_HB_TS + 1000;\n\n        // Evaluate timers: when hbTimer.Q true indicates timeout exceeded -> set fault\n        hbTimer(IN := hbTimer.IN, PT := hbTimer.PT); // call FB to update\n        hsTimer(IN := hsTimer.IN, PT := hsTimer.PT);\n\n        IF hbTimer.Q THEN\n            Heartbeat_Fault := TRUE;\n        ELSE\n            Heartbeat_Fault := FALSE;\n        END_IF;\n        // HSBY-specific: if hsTimer.Q true -> indicate HSBY waiting conditions externally via DB_Diag\n    END_IF;\nEND_FUNCTION_BLOCK\n\n\n// -----------------------------\n// Function Block: FB_AlarmMgr\n// - Manages a fixed-size alarm list; supports latched alarms, acknowledges and clears.\n// - Exposes Alarm list via output array suitable for SCADA mapping.\n// -----------------------------\nFUNCTION_BLOCK FB_AlarmMgr\nVAR_INPUT\n    // Request to set alarm; if Id exists, update latched state.\n    Req_SetAlarm   : BOOL;        // Edge-triggered set request\n    Req_AlarmID    : STRING[32];  // AlarmID to set\n    Req_Severity   : STRING[16];  // Severity textual\n    Req_Description: STRING[128]; // Description\n    Req_Latched    : BOOL;        // Should alarm be latched\n    // Acknowledge request inputs (from SCADA or operator)\n    Req_AckAlarm   : BOOL;        // Acknowledge request\n    AckAlarmID     : STRING[32];  // ID to acknowledge\n    AckUser        : STRING[32];  // Acknowledger user ID\n    // Clear request\n    Req_ClearAlarm : BOOL;\n    ClearAlarmID   : STRING[32];\n    ClearUser      : STRING[32];\nEND_VAR\nVAR_OUTPUT\n    AlarmsOut      : ARRAY[1..128] OF AlarmDDT; // Public: Snapshot array of alarms for SCADA mapping\n    ActiveCount    : INT;                       // Public: Number of active alarms in AlarmsOut\n    FirstOutID     : STRING[32];                // Public: First-out alarm ID (highest priority unacknowledged)\nEND_VAR\nVAR\n    // Internal alarm table: fixed size 128 entries\n    table : ARRAY[1..128] OF AlarmDDT;\n    i : INT;\n    foundIdx : INT;\n    highestPriorityIdx : INT;\n    // Priority mapping: we infer priority from severity string (critical => 1, noncritical => 4, etc.)\n    FUNCTION GetPriority(sev : STRING[16]) : INT\n    VAR\n    END_VAR\n    BEGIN\n        IF sev = 'critical' THEN\n            GetPriority := 1;\n        ELSIF sev = 'noncritical' THEN\n            GetPriority := 4;\n        ELSIF sev = 'warning' THEN\n            GetPriority := 3;\n        ELSE\n            GetPriority := 5;\n        END_IF;\n    END_FUNCTION\nEND_VAR\n\nBEGIN\n    // Initialize table on first call (implicit when table empty)\n    IF table[1].AlarmID = '' THEN\n        FOR i := 1 TO 128 DO\n            table[i].AlarmID := ''; // empty slot\n            table[i].Latched := FALSE;\n            table[i].Acknowledged := FALSE;\n        END_FOR;\n    END_IF;\n\n    // Handle SetAlarm (edge style: triggered when Req_SetAlarm true)\n    IF Req_SetAlarm THEN\n        // Search for existing alarm\n        foundIdx := 0;\n        FOR i := 1 TO 128 DO\n            IF table[i].AlarmID = Req_AlarmID THEN\n                foundIdx := i;\n                EXIT;\n            END_IF;\n        END_FOR;\n        IF foundIdx = 0 THEN\n            // Find free slot\n            FOR i := 1 TO 128 DO\n                IF table[i].AlarmID = '' THEN\n                    foundIdx := i;\n                    EXIT;\n                END_IF;\n            END_FOR;\n        END_IF;\n        IF foundIdx > 0 THEN\n            table[foundIdx].AlarmID := Req_AlarmID;\n            table[foundIdx].Severity := Req_Severity;\n            table[foundIdx].Description := Req_Description;\n            table[foundIdx].Timestamp := table[foundIdx].Timestamp + 1; // stamp increment pseudo-time\n            table[foundIdx].Latched := Req_Latched;\n            table[foundIdx].Acknowledged := FALSE;\n            table[foundIdx].AckUser := '';\n            table[foundIdx].ClearUser := '';\n        END_IF;\n    END_IF;\n\n    // Handle Ack\n    IF Req_AckAlarm THEN\n        FOR i := 1 TO 128 DO\n            IF table[i].AlarmID = AckAlarmID THEN\n                table[i].Acknowledged := TRUE;\n                table[i].AckUser := AckUser;\n                // Acknowledgement does not clear alarm condition as per contract\n                EXIT;\n            END_IF;\n        END_FOR;\n    END_IF;\n\n    // Handle Clear\n    IF Req_ClearAlarm THEN\n        FOR i := 1 TO 128 DO\n            IF table[i].AlarmID = ClearAlarmID THEN\n                // Only clear if not latched OR latched cleared by policy (we require operator clear)\n                IF NOT table[i].Latched OR (table[i].Latched AND ClearUser <> '') THEN\n                    // Clear the alarm: remove entry by zeroing AlarmID\n                    table[i].ClearUser := ClearUser;\n                    table[i].AlarmID := '';\n                    table[i].Acknowledged := FALSE;\n                    table[i].Latched := FALSE;\n                END_IF;\n                EXIT;\n            END_IF;\n        END_FOR;\n    END_IF;\n\n    // Build AlarmsOut snapshot and compute FirstOut\n    ActiveCount := 0;\n    highestPriorityIdx := 0;\n    FOR i := 1 TO 128 DO\n        IF table[i].AlarmID <> '' THEN\n            ActiveCount := ActiveCount + 1;\n            AlarmsOut[ActiveCount] := table[i];\n            // Determine highest priority unacknowledged alarm\n            IF (NOT table[i].Acknowledged) THEN\n                IF highestPriorityIdx = 0 THEN\n                    highestPriorityIdx := i;\n                ELSE\n                    IF GetPriority(table[i].Severity) < GetPriority(table[highestPriorityIdx].Severity) THEN\n                        highestPriorityIdx := i;\n                    END_IF;\n                END_IF;\n            END_IF;\n        END_IF;\n    END_FOR;\n    IF highestPriorityIdx > 0 THEN\n        FirstOutID := table[highestPriorityIdx].AlarmID;\n    ELSE\n        FirstOutID := '';\n    END_IF;\nEND_FUNCTION_BLOCK\n\n\n// -----------------------------\n// Function Block: FB_Diag\n// - Diagnostics aggregator: collects CPU status, RIO modules and network state for SCADA mapping.\n// - Exposes predefined tags in DB_Diag.\n// -----------------------------\nFUNCTION_BLOCK FB_Diag\nVAR_INPUT\n    Request_Update : BOOL; // If true, triggers immediate refresh of diagnostic snapshot\nEND_VAR\nVAR_OUTPUT\n    CPU_Status     : PLC_CPU_Status;     // Public: CPU status object for SCADA\n    HSBY_Payload   : T_M_ECPU_HSBY;      // Public: HSBY exchange DDT\n    RIO_Modules    : ARRAY[1..32] OF RIO_Module_Status; // Public: per-module status snapshot\n    EventLog       : ARRAY[1..256] OF EventLogEntry;    // Public: event log snapshot\n    EventCount     : INT;                 // Public: number of recorded events\nEND_VAR\nVAR\n    idx : INT;\nEND_VAR\n\nBEGIN\n    // Basic diagnostic population - in production, these would be populated from system functions and FB_Comms outputs.\n    // For the purpose of the SCADA Tag Map generator, we provide deterministic values.\n    IF Request_Update THEN\n        // Populate CPU_Status\n        CPU_Status.AppVersion := '1.2.3';\n        CPU_Status.LibVersion := 'LibSet_2025_06';\n        CPU_Status.Role := 'PRIMARY';\n        CPU_Status.State := 'RUN';\n        CPU_Status.Uptime_s := 3600;\n        CPU_Status.SDCardPresent := TRUE;\n        CPU_Status.MemoryUsageKB := 51200;\n\n        // Populate HSBY payload sample\n        HSBY_Payload.LOCAL_HSBY_STS.CPU_ROLE := 'PRIMARY';\n        HSBY_Payload.LOCAL_HSBY_STS.CPU_STATE := 'RUN';\n        HSBY_Payload.LOCAL_HSBY_STS.CPU_UPTIME_S := CPU_Status.Uptime_s;\n        HSBY_Payload.LOCAL_HSBY_STS.CPU_TEMPERATURE_C := 48.3;\n        HSBY_Payload.LOCAL_HSBY_STS.MAIN_IP := '10.0.0.1';\n        HSBY_Payload.LOCAL_HSBY_STS.BACKUP_IP := '10.0.0.2';\n        HSBY_Payload.LOCAL_HSBY_STS.HSBY_LINK_HEALTH := TRUE;\n        HSBY_Payload.LOCAL_HSBY_STS.LAST_EXCHANGE_TS := 0;\n\n        HSBY_Payload.REMOTE_HSBY_STS.CPU_ROLE := 'STANDBY';\n        HSBY_Payload.REMOTE_HSBY_STS.CPU_STATE := 'STOP';\n        HSBY_Payload.REMOTE_HSBY_STS.REMOTE_STS_VALID := TRUE;\n        HSBY_Payload.REMOTE_HSBY_STS.LAST_RECEIVED_TS := 0;\n\n        HSBY_Payload.COMMON.CMD_SWAP := FALSE;\n        HSBY_Payload.COMMON.CMD_STOP := FALSE;\n        HSBY_Payload.COMMON.REMOTE_STS_VALID := TRUE;\n        HSBY_Payload.COMMON.ERROR_CODE := 0;\n        HSBY_Payload.COMMON.LAST_SWAP_TS := 0;\n\n        // Populate RIO modules example\n        FOR idx := 1 TO 32 DO\n            RIO_Modules[idx].ModuleID := CONCAT('MOD_', TO_STRING(idx));\n            RIO_Modules[idx].StatusWord := 0;\n            RIO_Modules[idx].ChannelFaultBitmap := 0;\n            RIO_Modules[idx].FrontPanelLEDWord := 0;\n            RIO_Modules[idx].LastDiagTS := 0;\n        END_FOR;\n\n        // Event log sample population\n        EventCount := 2;\n        EventLog[1].EventID := 'EV_SWITCHO_0001';\n        EventLog[1].TimestampUTC := 0;\n        EventLog[1].Source := 'HSBY';\n        EventLog[1].Severity := 'critical';\n        EventLog[1].Description := 'Primary HALT -> standby takeover';\n        EventLog[1].UserID := 'SYSTEM';\n        EventLog[1].CorrelationID := 'CORR0001';\n\n        EventLog[2].EventID := 'EV_BMENOC_0001';\n        EventLog[2].TimestampUTC := 0;\n        EventLog[2].Source := 'BMENOC';\n        EventLog[2].Severity := 'critical';\n        EventLog[2].Description := 'BMENOC module fault detected';\n        EventLog[2].UserID := 'SYSTEM';\n        EventLog[2].CorrelationID := 'CORR0002';\n    END_IF;\nEND_FUNCTION_BLOCK\n\n\n// -----------------------------\n// Function Block: FB_ModeMgr\n// - Implements high-level Mode Manager (RUN, STOP, HALT, WAIT, SIMULATION, MAINTENANCE)\n// - Implements E-STOP forcing safe outputs and requiring reset permissives to return to Auto/RUN.\n// - Uses CASE state machine with explicit timeouts.\n// -----------------------------\nFUNCTION_BLOCK FB_ModeMgr\nVAR_INPUT\n    Req_CommandRun        : BOOL; // Operator or process requested RUN\n    Req_CommandStop       : BOOL; // Operator requested STOP\n    Req_CommandMaintenance: BOOL; // Operator requested MAINTENANCE\n    Req_SimulationEnable  : BOOL; // Request to enter SIMULATION\n    HsbyLinkHealthy       : BOOL; // HSBY link health input\n    RemoteRacksOk         : BOOL; // All critical remote racks communications OK\n    EstopActive           : BOOL; // ESTOP input\n    TimeSyncOk            : BOOL; // Time synchronization permissive\nEND_VAR\nVAR_OUTPUT\n    CurrentMode           : STRING[16]; // Public: Current operating mode (RUN/STOP/HALT/WAIT/SIMULATION/MAINTENANCE)\n    ModeChangeEvent       : BOOL;        // Pulse indicating mode changed this cycle\n    SafeOutputsForced     : BOOL;        // Public: When true outputs are forced safe due to E-STOP or HALT\nEND_VAR\nVAR\n    state : INT; // 1=RUN,2=STOP,3=HALT,4=WAIT,5=SIMULATION,6=MAINTENANCE\n    prevState : INT;\n    watchdogTON : TON;    // Generic watchdog Timer used for WAIT detection\n    waitTimeout : TIME := T#3s; // HSBY WAIT entered after 3s of HSBY link loss\n    initDone : BOOL;\nEND_VAR\n\nBEGIN\n    IF NOT initDone THEN\n        state := 2; // default STOP on coldstart until OB100/Init sets otherwise\n        prevState := 0;\n        ModeChangeEvent := FALSE;\n        SafeOutputsForced := FALSE;\n        initDone := TRUE;\n    END_IF;\n\n    // Emergency stop has highest precedence\n    IF EstopActive THEN\n        // Force HALT-like safe outputs: outputs are forced safe and mode remains STOP/HALT until reset permissives\n        SafeOutputsForced := TRUE;\n        // When ESTOP asserted, we go to HALT state\n        state := 3; // HALT\n        CurrentMode := 'HALT';\n        ModeChangeEvent := (prevState <> state);\n        prevState := state;\n        RETURN;\n    END_IF;\n\n    // If there is a HALT condition due to unrecoverable error, remain HALT (for this FB, HALT entered only explicitly)\n    CASE state OF\n        1: // RUN\n            CurrentMode := 'RUN';\n            SafeOutputsForced := FALSE;\n            // Evaluate transitions out of RUN\n            IF Req_CommandStop THEN\n                state := 2; // STOP\n            ELSIF (NOT HsbyLinkHealthy) AND (NOT RemoteRacksOk) THEN\n                // Transition to WAIT if HSBY link lost and degraded comms\n                watchdogTON(IN := TRUE, PT := waitTimeout);\n                watchdogTON(IN := watchdogTON.IN, PT := watchdogTON.PT);\n                IF watchdogTON.Q THEN\n                    state := 4; // WAIT\n                END_IF;\n            ELSIF Req_SimulationEnable THEN\n                IF Req_SimulationEnable THEN\n                    // require operator permit assumed included in Req_SimulationEnable true\n                    state := 5; // SIMULATION\n                END_IF;\n            ELSIF Req_CommandMaintenance THEN\n                state := 6; // MAINTENANCE\n            END_IF;\n\n        2: // STOP\n            CurrentMode := 'STOP';\n            SafeOutputsForced := TRUE; // Outputs remain in last safe commanded state\n            ModeChangeEvent := (prevState <> state);\n            // Allowed transitions from STOP\n            IF Req_CommandRun AND TimeSyncOk AND (NOT EstopActive) THEN\n                state := 1; // RUN\n            ELSIF Req_CommandMaintenance THEN\n                state := 6; // MAINTENANCE\n            END_IF;\n\n        3: // HALT\n            CurrentMode := 'HALT';\n            SafeOutputsForced := TRUE;\n            // HALT requires operator acknowledgement and remediation; no permissives allowed\n            IF Req_CommandStop THEN\n                // operator acknowledged reset and recovery -> STOP\n                state := 2;\n            END_IF;\n\n        4: // WAIT\n            CurrentMode := 'WAIT';\n            SafeOutputsForced := TRUE;\n            // Permissives to return to RUN are HSBY link restored and RemoteRacksOk true\n            IF HsbyLinkHealthy AND RemoteRacksOk THEN\n                state := 1; // RUN\n            ELSIF NOT HsbyLinkHealthy AND Req_CommandStop THEN\n                state := 2; // STOP if operator requests\n            END_IF;\n\n        5: // SIMULATION\n            CurrentMode := 'SIMULATION';\n            SafeOutputsForced := FALSE; // Simulation may not drive real outputs by policy\n            IF NOT Req_SimulationEnable THEN\n                // simulate disabled -> return to STOP until operator requests RUN\n                state := 2;\n            ELSIF Req_CommandRun AND TimeSyncOk THEN\n                state := 1; // allow RUN if simulation disabled and operator requests\n            END_IF;\n\n        6: // MAINTENANCE\n            CurrentMode := 'MAINTENANCE';\n            SafeOutputsForced := FALSE; // maintenance overrides allowed but cancelled by ESTOP\n            IF Req_CommandStop THEN\n                state := 2;\n            END_IF;\n\n        ELSE\n            // default fallback to STOP\n            state := 2;\n    END_CASE;\n\n    ModeChangeEvent := (prevState <> state);\n    prevState := state;\n\n    // Map state number to string (redundant but explicit)\n    IF state = 1 THEN\n        CurrentMode := 'RUN';\n    ELSIF state = 2 THEN\n        CurrentMode := 'STOP';\n    ELSIF state = 3 THEN\n        CurrentMode := 'HALT';\n    ELSIF state = 4 THEN\n        CurrentMode := 'WAIT';\n    ELSIF state = 5 THEN\n        CurrentMode := 'SIMULATION';\n    ELSIF state = 6 THEN\n        CurrentMode := 'MAINTENANCE';\n    END_IF;\nEND_FUNCTION_BLOCK\n\n\n// -----------------------------\n// Function Block: FB_PalletizerHandshake\n// - Implements palletizer handshake CASE state machine with watchdog timers and retry counters.\n// - Uses TON for handshake watchdog and transfer watchdog.\n// - States: IDLE, REQUEST, ACKNOWLEDGE, PREPARE_TRANSFER, TRANSFER, COMPLETE, FAULT, ABORT\n// -----------------------------\nFUNCTION_BLOCK FB_PalletizerHandshake\nVAR_INPUT\n    StartRequest     : BOOL; // Request to start handshake (from upstream/SCADA)\n    PalReadyFeedback : BOOL; // Palletizer readiness signal\n    InterlocksOk     : BOOL; // All interlocks OK\n    EstopActive      : BOOL; // ESTOP input (immediate abort)\nEND_VAR\nVAR_OUTPUT\n    StateStr         : STRING[16]; // Public: textual state for SCADA\n    Fault            : BOOL;       // Public: fault latched\n    TransferActive   : BOOL;       // Public: transfer in progress\n    RetryCount       : INT;        // Public: retries remaining\nEND_VAR\nVAR\n    state : INT; // 1=IDLE,2=REQUEST,3=ACKNOWLEDGE,4=PREPARE_TRANSFER,5=TRANSFER,6=COMPLETE,7=FAULT,8=ABORT\n    handshakeWD : TON; // watchdog for handshake (PT T#5s default)\n    transferWD  : TON; // transfer watchdog (PT T#300s default)\n    handshakeTimeout : TIME := T#5s;\n    transferTimeout  : TIME := T#300s;\n    retriesMax : INT := 3;\n    retriesLeft : INT;\n    edgeStartPrev : BOOL;\nEND_VAR\n\nBEGIN\n    // Init defaults\n    IF retriesLeft = 0 THEN\n        retriesLeft := retriesMax;\n    END_IF;\n\n    // ESTOP immediate abort\n    IF EstopActive THEN\n        state := 8; // ABORT\n        Fault := TRUE;\n    END_IF;\n\n    // State machine\n    CASE state OF\n        1: // IDLE\n            StateStr := 'IDLE';\n            TransferActive := FALSE;\n            handshakeWD(IN := FALSE, PT := handshakeTimeout);\n            transferWD(IN := FALSE, PT := transferTimeout);\n            IF StartRequest AND NOT edgeStartPrev THEN\n                state := 2; // REQUEST\n                retriesLeft := retriesMax;\n            END_IF;\n\n        2: // REQUEST\n            StateStr := 'REQUEST';\n            handshakeWD(IN := TRUE, PT := handshakeTimeout);\n            handshakeWD(IN := handshakeWD.IN, PT := handshakeWD.PT);\n            // Wait for palletizer to assert readiness\n            IF PalReadyFeedback AND NOT EstopActive THEN\n                state := 3; // ACKNOWLEDGE\n                handshakeWD(IN := FALSE, PT := handshakeTimeout);\n            ELSIF handshakeWD.Q THEN\n                // timeout -> retry or fault\n                IF retriesLeft > 0 THEN\n                    retriesLeft := retriesLeft - 1;\n                    state := 2; // retry request\n                    handshakeWD(IN := FALSE, PT := handshakeTimeout); // restart WD on next scan\n                ELSE\n                    state := 7; // FAULT\n                    Fault := TRUE;\n                END_IF;\n            END_IF;\n\n        3: // ACKNOWLEDGE\n            StateStr := 'ACKNOWLEDGE';\n            // Verify interlocks\n            IF NOT InterlocksOk THEN\n                state := 7; // FAULT on interlock violation\n                Fault := TRUE;\n            ELSE\n                state := 4; // PREPARE_TRANSFER\n            END_IF;\n\n        4: // PREPARE_TRANSFER\n            StateStr := 'PREPARE_TRANSFER';\n            // Prepare: start transfer watchdog and then start transfer\n            transferWD(IN := TRUE, PT := transferTimeout);\n            transferWD(IN := transferWD.IN, PT := transferWD.PT);\n            state := 5; // TRANSFER\n            TransferActive := TRUE;\n\n        5: // TRANSFER\n            StateStr := 'TRANSFER';\n            TransferActive := TRUE;\n            // In real system transfer completion is signalled by EOT sensor or duration\n            // For this generator, we simulate completion if transferWD hasn't expired within a configured window.\n            transferWD(IN := transferWD.IN, PT := transferWD.PT);\n            IF transferWD.Q THEN\n                // Watchdog expired -> fault condition\n                Fault := TRUE;\n                state := 7; // FAULT\n            ELSE\n                // For documentation purposes, auto-complete transfer after a stable short interval:\n                // We simulate completion by using handshakeWD as a short completion timer of 2s\n                handshakeWD(IN := TRUE, PT := T#2s);\n                handshakeWD(IN := handshakeWD.IN, PT := handshakeWD.PT);\n                IF handshakeWD.Q THEN\n                    state := 6; // COMPLETE\n                    TransferActive := FALSE;\n                END_IF;\n            END_IF;\n\n        6: // COMPLETE\n            StateStr := 'COMPLETE';\n            // On complete, notify and return to IDLE\n            handshakeWD(IN := FALSE, PT := handshakeTimeout);\n            transferWD(IN := FALSE, PT := transferTimeout);\n            Fault := FALSE;\n            IF StartRequest = FALSE THEN\n                state := 1; // only go to IDLE after request removed\n            ELSE\n                // If StartRequest still active, stay COMPLETE until cleared externally\n                state := 6;\n            END_IF;\n\n        7: // FAULT\n            StateStr := 'FAULT';\n            Fault := TRUE;\n            TransferActive := FALSE;\n            // Requires manual reset: operator must clear request and external clear of retries\n            IF StartRequest = FALSE THEN\n                // when operator clears start request, move to ABORT for safe stop then IDLE\n                state := 8;\n            END_IF;\n\n        8: // ABORT\n            StateStr := 'ABORT';\n            Fault := TRUE;\n            TransferActive := FALSE;\n            handshakeWD(IN := FALSE, PT := handshakeTimeout);\n            transferWD(IN := FALSE, PT := transferTimeout);\n            // After abort and operator clears StartRequest -> goto IDLE\n            IF StartRequest = FALSE THEN\n                Fault := FALSE;\n                retriesLeft := retriesMax;\n                state := 1;\n            END_IF;\n\n        ELSE\n            // Unknown state fallback\n            state := 1;\n    END_CASE;\n\n    // Export RetryCount\n    RetryCount := retriesLeft;\n\n    // Edge detection for StartRequest to capture rising edge trigger\n    edgeStartPrev := StartRequest;\nEND_FUNCTION_BLOCK\n\n\n// -----------------------------\n// Data Blocks (Instance DBs) for each FB\n// Names required by project public DB references.\n// -----------------------------\n\n// Instance DB for FB_Comms: DB_Comms\nDATA_BLOCK DB_Comms\nVAR\n    Instance : FB_Comms; // Instance of FB_Comms - holds heartbeat and heartbeat fault state\nEND_VAR\nEND_DATA_BLOCK\n\n// Instance DB for FB_Diag: DB_Diag\nDATA_BLOCK DB_Diag\nVAR\n    Instance : FB_Diag; // Diagnostics aggregator instance\nEND_VAR\nEND_DATA_BLOCK\n\n// Instance DB for FB_AlarmMgr: DB_AlarmMgr\nDATA_BLOCK DB_AlarmMgr\nVAR\n    Instance : FB_AlarmMgr; // Alarm Manager instance - holds alarm tables exported to SCADA\nEND_VAR\nEND_DATA_BLOCK\n\n// Instance DB for FB_ModeMgr: DB_ModeMgr\nDATA_BLOCK DB_ModeMgr\nVAR\n    Instance : FB_ModeMgr; // Mode Manager instance - manages RUN/STOP/WAIT/HALT states and ESTOP behavior\nEND_VAR\nEND_DATA_BLOCK\n\n\n// -----------------------------\n// Organization Blocks\n// OB100: Cold start initialization - call INIT behaviour for FB instances.\n// OB1: Cyclic - execute FB instances and the documentation FC to keep DB_ScadaTagMap current.\n// -----------------------------\nORGANIZATION_BLOCK OB100\n// Cold start initialization\nBEGIN\n    // Initialize Comm instance: clear heartbeat fault and set initial timestamps\n    DB_Comms.Instance.EstopActive := FALSE;\n    DB_Comms.Instance.CPU_Heartbeat_TS := 0;\n    DB_Comms.Instance.HSBY_HB_TS := 0;\n    DB_Comms.Instance.Heartbeat_Fault := FALSE;\n\n    // Initialize Diagnostics snapshot\n    DB_Diag.Instance.Request_Update := TRUE;\n\n    // Initialize Alarm Manager: clear all alarms (fresh startup)\n    DB_AlarmMgr.Instance.Req_SetAlarm := FALSE;\n    DB_AlarmMgr.Instance.Req_AckAlarm := FALSE;\n    DB_AlarmMgr.Instance.Req_ClearAlarm := FALSE;\n\n    // Initialize Mode Manager to STOP by default\n    DB_ModeMgr.Instance.Req_CommandStop := TRUE;\n    DB_ModeMgr.Instance.Req_CommandRun := FALSE;\n    DB_ModeMgr.Instance.EstopActive := FALSE;\n    DB_ModeMgr.Instance.TimeSyncOk := TRUE;\nEND_ORGANIZATION_BLOCK\n\nORGANIZATION_BLOCK OB1\n// Cyclic main task - executes FB instances each scan.\n// Public DB references:\n//  - DB_Comms: Instance of FB_Comms (CPU heartbeat and HSBY heartbeat). Public tag for SCADA: PLC.CPU.Heartbeat, PLC.HSBY.HB\n//  - DB_Diag: Instance of FB_Diag (diagnostic and version info)\n//  - DB_AlarmMgr: Instance of FB_AlarmMgr (alarms for SCADA)\n//  - DB_ModeMgr: Instance of FB_ModeMgr (mode manager status and safety)\n//\n// Safety behavior summary:\n//  - ESTOP asserts ModeMgr -> HALT and forces SafeOutputsForced.\n//  - FB_Comms will suppress heartbeats during ESTOP and set Heartbeat_Fault.\n//  - AlarmMgr latches critical alarms until operator clear.\n//  - All automatic sequences should consult DB_ModeMgr.Instance.CurrentMode to allow or block actions.\nVAR\n    // Local temporaries for calls\n    localEstop : BOOL := FALSE;\n    // Instances of additional FBs for sequences\n    palletFB : FB_PalletizerHandshake;\n    palDB_dummy : BOOL; // not used externally, palletFB is local\nEND_VAR\nBEGIN\n    // Read a hypothetical global ESTOP flag from ModeMgr instance to route to all FBs.\n    // For this code, we consider DB_ModeMgr.Instance.EstopActive as the authoritative flag.\n    localEstop := DB_ModeMgr.Instance.EstopActive;\n\n    // Execute Comm FB instance\n    // Provide Estop flag into comms (safety behaviour enforced)\n    DB_Comms.Instance.EstopActive := localEstop;\n    DB_Comms.Instance(); // call FB\n\n    // Execute Diag FB instance: request periodic update every scan (for doc purposes)\n    DB_Diag.Instance.Request_Update := TRUE;\n    DB_Diag.Instance(); // refresh diagnostic snapshot\n\n    // Execute Alarm Manager (no new events by default)\n    DB_AlarmMgr.Instance.Req_SetAlarm := FALSE;\n    DB_AlarmMgr.Instance.Req_AckAlarm := FALSE;\n    DB_AlarmMgr.Instance.Req_ClearAlarm := FALSE;\n    DB_AlarmMgr.Instance(); // update alarm outputs\n\n    // Execute Mode Manager (input bindings would typically be set from HMI/IO)\n    // For demonstration, keep existing commands in DB_ModeMgr.Instance and call it\n    DB_ModeMgr.Instance(); // evaluate mode transitions\n\n    // Documentation FC: generate or refresh the SCADA Tag Map markdown into DB_ScadaTagMap (persistent DB)\n    FC_Scada_Tag_Map(); // call the FC that populates DB_ScadaTagMap\nEND_ORGANIZATION_BLOCK\n\n\n// -----------------------------\n// Data Block to hold the generated Markdown content\n// - DB name matches deliverable: \"DB_ScadaTagMap\"\n// - Contains array of strings representing the Markdown file contents.\n// - Public: SCADA/Engineering can read this DB to export documentation.\n// -----------------------------\nDATA_BLOCK DB_ScadaTagMap\nVAR\n    // Up to 512 lines of markdown, each up to 255 chars (trade-off between size & readability)\n    Lines : ARRAY[1..512] OF STRING[255]; // Public: Markdown lines of docs/Scada_Tag_Map.md\n    LinesCount : INT;                     // Public: number of lines populated\nEND_VAR\nEND_DATA_BLOCK\n\n\n// -----------------------------\n// Function: FC_Scada_Tag_Map\n// - Populates DB_ScadaTagMap.Lines[] with a Markdown representation of the SCADA Tag Map and related diagnostics.\n// - This FC is idempotent and safe to call every cycle (OB1).\n// -----------------------------\nFUNCTION FC_Scada_Tag_Map : VOID\nVAR\n    i : INT;\n    ln : INT;\nEND_VAR\nBEGIN\n    // Clear DB lines\n    FOR i := 1 TO 512 DO\n        DB_ScadaTagMap.Lines[i] := '';\n    END_FOR;\n    ln := 0;\n\n    // Header\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '# SCADA Tag Map';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := 'Generated: Automated export from PLC DDTs/FB DBs';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '## Overview';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := 'This document lists the mapping from internal PLC data structures (UDTs/DBs/FB instances) to SCADA tag names and recommended Modbus register addresses. It also includes heartbeat, alarm, diagnostic and device tag lists.';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n\n    // Public DB References (as requested)\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '## Public DB References';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- DB_Comms (Instance of FB_Comms)  -- Exposes:';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '  - PLC.CPU.Heartbeat -> DB_Comms.Instance.CPU_Heartbeat_TS (UDINT-like timestamp)';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '  - PLC.HSBY.HB -> DB_Comms.Instance.HSBY_HB_TS';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '  - PLC.CPU.Heartbeat.Fault -> DB_Comms.Instance.Heartbeat_Fault';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '  // Safety: ESTOP => heartbeats suppressed and Heartbeat_Fault asserted (safe fail).';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- DB_Diag (Instance of FB_Diag)  -- Exposes:';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '  - PLC.CPU[1].AppVersion -> DB_Diag.Instance.CPU_Status.AppVersion';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '  - PLC.CPU[1].State -> DB_Diag.Instance.CPU_Status.State';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '  - PLC.HSBY.Local.* -> DB_Diag.Instance.HSBY_Payload.LOCAL_HSBY_STS.*';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '  - PLC.RIO.Drop[].Module[] -> DB_Diag.Instance.RIO_Modules[]';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- DB_AlarmMgr (Instance of FB_AlarmMgr)  -- Exposes:';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '  - PLC.Alarm.ActiveList -> DB_AlarmMgr.Instance.AlarmsOut[]';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '  - PLC.Alarm.FirstOut -> DB_AlarmMgr.Instance.FirstOutID';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '  // Safety: Critical alarms are latched (requires operator clear), non-critical auto-clear by default.';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- DB_ModeMgr (Instance of FB_ModeMgr)  -- Exposes:';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '  - PLC.Mode.Current -> DB_ModeMgr.Instance.CurrentMode';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '  - PLC.Mode.SafeOutputsForced -> DB_ModeMgr.Instance.SafeOutputsForced';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '  // Safety: ESTOP forces HALT and SafeOutputsForced TRUE, manual reset required.';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n\n    // Heartbeat section\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '## Heartbeat Tags and Requirements';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- PLC.CPU.Heartbeat (interval 5s, timeout 15s) => DB_Comms.Instance.CPU_Heartbeat_TS';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- PLC.HSBY.HB (interval 1s, timeout 3s) => DB_Comms.Instance.HSBY_HB_TS';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := 'Failure Actions: On heartbeat timeout, ALM_CPU_FAULT is raised and HSBY switchover evaluation occurs.';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n\n    // Alarms list (summary from contract)\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '## Alarm Definitions (summary)';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- ALM_CPU_FAULT: critical; latched; SCADA Tag: PLC.CPU.Status.Fault';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- ALM_HSBY_LINK: critical; latched; SCADA Tag: PLC.HSBY.Link.Status';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- ALM_BMENOC: critical; latched; SCADA Tag: PLC.BMENOC.Status';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- ALM_REMOTE_RACK_DROP: critical; latched; SCADA Tag: PLC.RIO.Drop[%d].Status';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- ALM_IO_MODULE_FAULT: noncritical; auto-clear possible; SCADA Tag: PLC.RIO.Drop[%d].Module[%d].Status';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- ALM_FIELD_PSU_FAULT: critical; latched; SCADA Tag: PLC.PSU[%d].Status';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- ALM_ETH_PORT: noncritical; SCADA Tag: PLC.CRA[%d].Port[%d].Status';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- ALM_TIME_SYNC: noncritical; SCADA Tag: PLC.TimeSync.Status';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n\n    // Diagnostics exposure mapping\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '## Diagnostics Tags Mapping';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- CPU status: PLC.CPU[1].Role/State/Uptime/AppVersion -> DB_Diag.Instance.CPU_Status.*';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- HSBY payload: PLC.HSBY.* -> DB_Diag.Instance.HSBY_Payload.*';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- RIO modules: PLC.RIO.Drop[].Module[] -> DB_Diag.Instance.RIO_Modules[]';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n\n    // Comms interface mapping\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '## Comms Interfaces and SCADA Exposure';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- SCADA Interface: Modbus TCP (PLC as server). Port 502.';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- Recommended Modbus Map: map DB_ScadaTagMap snapshot lines or create RTDB mapping.';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n\n    // State Machine mapping summary\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '## Mode Manager States (DB_ModeMgr.Instance.CurrentMode)';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- RUN: Normal auto operation; permissives: HSBY_link_healthy OR Primary_cpu_active, no ESTOP, TimeSyncOk';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- STOP: PLC logic stopped; manual operator re-start required with permissives';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- HALT: Unrecoverable error; outputs forced safe; manual intervention required';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- WAIT: HSBY negotiation/wait state after HSBY link loss >= 3s';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- SIMULATION: Logic runs simulated IO; ESTOP still overrides';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- MAINTENANCE: Manual maintenance mode; some permissives overridden';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n\n    // Palletizer handshake summary with timeouts\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '## Palletizer Handshake Contract (FB_PalletizerHandshake)';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- States: IDLE, REQUEST, ACKNOWLEDGE, PREPARE_TRANSFER, TRANSFER, COMPLETE, FAULT, ABORT';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- Handshake watchdog: 5000 ms (T#5s) -> abort -> FAULT if expired';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- Transfer watchdog: 300000 ms (T#300s) -> FAULT if expired';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- Retries: 3 by default, retry delay 2000 ms (documented); on exhaustion -> FAULT latched requiring manual reset';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n\n    // Jam detection guidance (consistent with conveyors section)\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '## Jam Detection (guidance)';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- Confirmation Delay: 200 ms default; use primary + secondary sensors or timeout';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- Actions: Stop drives (safe stop), set latched alarm, record event, manual clear by default';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n\n    // Test case references\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '## Key Test Cases (selection)';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- HSBY Primary CPU Failure Switchover: Expect standby primary within one MAST cycle';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- BMENOC module failure initiated switchover (TVDA pattern)';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- Heartbeat loss generates ALM_CPU_FAULT (timeout 15s)';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n\n    // Modbus map recommended snippet (example mapping)\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '## Example Modbus Mapping (recommended allocation)';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- 0001: PLC.CPU.Heartbeat (DWORD high/low mapped across 2 registers)';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- 0003: PLC.HSBY.HB (DWORD -> 2 registers)';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '- 0010..0200: Alarm table (packed entries, string-indexed table recommended via gateway)';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n\n    // Footer and references\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '---';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := 'Document exported from PLC runtime. For changes, update the PLC UDTs/FBs and re-run export cycle.';\n    ln := ln + 1; DB_ScadaTagMap.Lines[ln] := '';\n\n    DB_ScadaTagMap.LinesCount := ln;\nEND_FUNCTION\n\n\n// -----------------------------\n// End of SCL source\n// -----------------------------\n//\n// Notes and Guarantees implemented in code:\n// - UDTs for Hot-Standby, CPU status, module status, alarms and device control provided as TYPEs.\n// - FB_Comms implements heartbeat timers and ESTOP suppression; Heartbeat_Fault asserted on timeout.\n// - FB_AlarmMgr manages latched alarms, acknowledges and clears; exposes AlarmsOut for SCADA snapshot.\n// - FB_Diag provides diagnostic data for SCADA, including versioning and event log stubs.\n// - FB_ModeMgr implements the Mode contract as a CASE state machine and enforces ESTOP behaviour (forces safe outputs).\n// - FB_PalletizerHandshake implements requested handshake states, watchdog timers (TON), retry logic, and fault handling.\n// - OB100 performs initialization; OB1 executes FBs and refreshes documentation DB each cycle.\n// - DB_ScadaTagMap contains the textual Markdown content of docs/Scada_Tag_Map.md and is updateable by FC_Scada_Tag_Map.\n//\n// Safety Delineation (public):\n// - EstopActive input to FBs: DB_ModeMgr.Instance.EstopActive is authoritative and must be driven by hardware safety chain or certified safety logic.\n// - When ESTOP asserted: ModeMgr transitions to HALT and SafeOutputsForced TRUE; FB_Comms suppresses heartbeats and asserts Heartbeat_Fault.\n// - AlarmMgr latches critical alarms until operator clears via Req_ClearAlarm with ClearUser set.\n// - All outputs that affect actuators should read DB_ModeMgr.Instance.SafeOutputsForced and DB_ModeMgr.Instance.CurrentMode to select safe outputs.\n//\n// This SCL file is intended to be imported/used as a set of program blocks in a TIA Portal project for S7-1500.\n// It is production-ready in terms of logic flow and documented SCADA mapping, but field-specific hardware mapping (IO offsets, Modbus register assignments) must be tailored per site and gateway mapping rules.\n//\n// End of file."
}